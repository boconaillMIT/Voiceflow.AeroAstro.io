// Replace your collectUserData() function with this secure version:

function collectUserData() {
    addDebugStep('Starting user data collection...', 'info');
    
    // Get data from URL parameters first
    const urlData = {
        name: getURLParameter('name'),
        firstName: getURLParameter('firstName'),
        lastName: getURLParameter('lastName'),
        kerberos: getURLParameter('kerberos'),
        email: getURLParameter('email'),
        title: getURLParameter('title'),
        department: getURLParameter('department'),
        groups: getURLParameter('groups'),
        // SECURITY FIX: NEVER trust authenticated parameter from URL
        authenticated: false  // Always start as false - will be set by server validation
    };

    addDebugStep(`URL Parameters: ${JSON.stringify(urlData, null, 2)}`, 'info');

    // Get data from localStorage
    const storedData = getStoredMetadata();
    addDebugStep(`localStorage Data: ${JSON.stringify(storedData, null, 2)}`, 'info');

    // Merge data (URL params take precedence over localStorage for user info)
    const userData = {
        name: urlData.name || (storedData && storedData.name) || 
              (urlData.firstName && urlData.lastName ? `${urlData.firstName} ${urlData.lastName}` : '') ||
              (storedData && storedData.firstName && storedData.lastName ? `${storedData.firstName} ${storedData.lastName}` : '') ||
              'User',
        firstName: urlData.firstName || (storedData && storedData.firstName) || '',
        lastName: urlData.lastName || (storedData && storedData.lastName) || '',
        kerberos: urlData.kerberos || (storedData && storedData.kerberos) || '',
        email: urlData.email || (storedData && storedData.email) || '',
        title: urlData.title || (storedData && storedData.title) || '',
        department: urlData.department || (storedData && storedData.department) || '',
        groups: urlData.groups || (storedData && storedData.groups) || '',
        // CRITICAL: Authentication is NEVER trusted from URL or localStorage
        // It must be validated server-side via Make.com
        authenticated: false,
        loginTime: (storedData && storedData.loginTime) || new Date().toISOString()
    };

    addDebugStep(`Collected user data (authentication pending validation): ${JSON.stringify(userData, null, 2)}`, 'info');
    return userData;
}

// Add this new function for secure server-side validation:
async function validateUserAccess(userData) {
    if (!userData.kerberos) {
        addDebugStep('No Kerberos ID provided - validation failed', 'error');
        return { authenticated: false, hasAccess: false, error: 'No Kerberos ID' };
    }

    if (!userData.department) {
        addDebugStep('No department provided - validation failed', 'error');
        return { authenticated: false, hasAccess: false, error: 'No department info' };
    }

    try {
        addDebugStep(`Validating user access via Make.com: ${userData.kerberos} (${userData.department})`, 'info');
        
        // Call your Make.com webhook for server-side validation
        const response = await fetch('https://hook.us2.make.com/nsevfwoyexfveb4goqoxk4eta2sadle2', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                kerberosId: userData.kerberos,
                department: userData.department
            })
        });

        if (!response.ok) {
            throw new Error(`Validation request failed: ${response.status}`);
        }

        const validationResult = await response.json();
        addDebugStep(`Make.com validation result: ${JSON.stringify(validationResult, null, 2)}`, 'success');

        // Handle different response formats from your Make.com webhook
        const hasAccess = validationResult.hasAccess === true || validationResult.hasAccess === "true" || validationResult.hasAccess === 1;
        const isFirstLogin = validationResult.isFirstLogin === true || validationResult.isFirstLogin === "true";
        const isExceptionUser = validationResult.isExceptionUser === true || validationResult.isExceptionUser === "true";

        return {
            authenticated: hasAccess,  // Only true if server validates access
            hasAccess: hasAccess,
            isFirstLogin: isFirstLogin,
            isExceptionUser: isExceptionUser,
            accessType: validationResult.accessType,
            error: null
        };

    } catch (error) {
        addDebugStep(`Validation error: ${error.message}`, 'error');
        return { 
            authenticated: false, 
            hasAccess: false, 
            error: error.message 
        };
    }
}

// Replace your initializePage() function with this secure version:
async function initializePage() {
    addDebugStep('Page initialization started with security validation', 'info');
    
    const userData = collectUserData();
    
    // SECURITY CHECK: Must have kerberos from OAuth to proceed
    if (!userData.kerberos) {
        addDebugStep('No Kerberos ID found - redirecting to login', 'warning');
        setTimeout(() => {
            window.location.href = 'login.html';
        }, 3000);
        return;
    }
    
    // Show loading state while validating
    document.getElementById('display-name').textContent = 'Validating access...';
    document.getElementById('user-info').classList.add('visible');
    
    addDebugStep('Performing server-side access validation...', 'info');
    
    // CRITICAL: Always validate via Make.com before granting access
    const validation = await validateUserAccess(userData);
    
    if (!validation.authenticated) {
        addDebugStep('Access denied by server validation', 'error');
        
        // Show access denied message
        document.body.innerHTML = `
            <div style="max-width: 600px; margin: 100px auto; padding: 40px; background: white; border-radius: 10px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                <h1 style="color: #e74c3c;">Access Denied</h1>
                <p>You are not authorized to access this chatbot.</p>
                <p><strong>Reason:</strong> You must be a member of the Department of Aeronautics and Astronautics or have special access granted.</p>
                <p><strong>Your Info:</strong> ${userData.kerberos} (${userData.department || 'Unknown Department'})</p>
                ${validation.error ? `<p><strong>Technical Details:</strong> ${validation.error}</p>` : ''}
                <p>If you believe this is an error, please contact the administrator.</p>
                <p><a href="login.html" style="background: #3498db; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px;">Try Login Again</a></p>
            </div>
        `;
        return;
    }
    
    addDebugStep('Server validation successful - granting access', 'success');
    
    // Update userData with validated authentication status
    userData.authenticated = true;
    userData.hasAccess = validation.hasAccess;
    userData.isFirstLogin = validation.isFirstLogin;
    userData.isExceptionUser = validation.isExceptionUser;
    
    updateUserDisplay(userData);
    const userID = generateUserID(userData);
    
    window.currentUser = userData;
    addDebugStep('User authenticated and currentUser variable set', 'success');
    
    // Clean URL after successful authentication
    cleanUrlAfterProcessing();
    
    loadVoiceflow(userID, userData);
}
