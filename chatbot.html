<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AeroAstro Chatbot</title>
   <style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(to bottom, #001a2e 0%, #003d5c 50%, #4a90b8 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
    }

    .header {
        background: linear-gradient(135deg, #003d5c 0%, #1e5a7a 50%, #4a90b8 100%);
        color: white;
        text-align: center;
        padding: 40px 20px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        position: relative;
    }

    .header h1 {
        font-size: 2.5em;
        font-weight: 600;
        margin-bottom: 10px;
    }

    .header p {
        font-size: 1.1em;
        opacity: 0.95;
        font-weight: 300;
    }

    .header-logo {
        position: absolute;
        top: 50%;
        left: 40px;
        transform: translateY(-50%);
        height: 60px;
        width: auto;
        opacity: 0.9;
    }

    .admin-link {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        padding: 10px 20px;
        border-radius: 6px;
        text-decoration: none;
        font-size: 0.9em;
        font-weight: 500;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
    }

    .admin-link:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    .user-info {
        background: white;
        padding: 15px 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        display: flex;
        justify-content: center;
        gap: 30px;
        flex-wrap: wrap;
        font-size: 0.95em;
    }

    .user-info span {
        color: #2c3e50;
    }

    .user-info strong {
        color: #003d5c;
        font-weight: 600;
    }

    .container {
        flex: 1;
        max-width: 1200px;
        width: 100%;
        margin: 0 auto;
        padding: 30px 20px;
        display: flex;
        flex-direction: column;
    }

    #chatContainer {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        margin-bottom: 20px;
        border: 2px solid #003d5c;
    }

    #chatMessages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        background: #f8f9fa;
    }

    .message {
        margin-bottom: 15px;
        padding: 12px 16px;
        border-radius: 8px;
        max-width: 80%;
        animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .user-message {
        background: #003d5c;
        color: white;
        margin-left: auto;
        text-align: right;
    }

    .bot-message {
        background: white;
        color: #2c3e50;
        border: 1px solid #e1e8ed;
        margin-right: auto;
    }

    .system-message {
        background: #fff3cd;
        color: #856404;
        text-align: center;
        margin: 10px auto;
        font-size: 0.9em;
        max-width: 100%;
    }

    .input-container {
        display: flex;
        gap: 10px;
        padding: 20px;
        background: white;
        border-top: 1px solid #e1e8ed;
    }

    #userInput {
        flex: 1;
        padding: 12px 16px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 1em;
        transition: all 0.3s ease;
    }

    #userInput:focus {
        outline: none;
        border-color: #003d5c;
        box-shadow: 0 0 0 3px rgba(0, 61, 92, 0.1);
    }

    #sendButton {
        padding: 12px 24px;
        background: #003d5c;
        color: white;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1em;
        font-weight: 500;
        transition: all 0.3s ease;
    }

    #sendButton:hover {
        background: #002a40;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    #sendButton:disabled {
        background: #95a5a6;
        cursor: not-allowed;
        transform: none;
    }

    .typing-indicator {
        display: none;
        padding: 10px;
        background: white;
        border: 1px solid #e1e8ed;
        border-radius: 8px;
        width: fit-content;
        margin-bottom: 15px;
    }

    .typing-indicator span {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #003d5c;
        margin: 0 2px;
        animation: bounce 1.4s infinite;
    }

    .typing-indicator span:nth-child(2) {
        animation-delay: 0.2s;
    }

    .typing-indicator span:nth-child(3) {
        animation-delay: 0.4s;
    }

    @keyframes bounce {
        0%, 60%, 100% {
            transform: translateY(0);
        }
        30% {
            transform: translateY(-10px);
        }
    }

    @media (max-width: 768px) {
        .header h1 {
            font-size: 1.8em;
        }

        .header-logo {
            height: 40px;
            left: 20px;
        }

        .admin-link {
            position: static;
            display: block;
            margin-top: 15px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }

        .message {
            max-width: 90%;
        }

        .user-info {
            gap: 15px;
            font-size: 0.85em;
        }
    }
</style>
</head>
<body>
<div class="header" style="position: relative;">
        <img src="AO-logo-low_color-left.png" alt="AeroAstro Logo" class="header-logo">
 
    <h1>AeroAstro Chatbot</h1>
    <p>AI Assistant for MIT's Department of Aeronautics and Astronautics</p>
    <!-- Admin button -->
    <div style="position: absolute; bottom: 10px; right: 15px;">
        <a href="admin.html" id="adminLink" style="display: none; color: rgba(255,255,255,0.8); text-decoration: none; font-size: 12px; padding: 4px 8px; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px;">Admin</a>
    </div>
</div>

    <div class="user-info" id="user-info">
        <div class="info-row">
            <span class="info-label">Welcome:</span>
            <span class="info-value" id="display-name">Loading...</span>
        </div>
        <div class="info-row">
            <span class="info-label">Kerberos:</span>
            <span class="info-value" id="display-kerberos">Loading...</span>
        </div>
        <div class="info-row">
            <span class="info-label">Title:</span>
            <span class="info-value" id="display-title">Loading...</span>
        </div>
        <div class="info-row">
            <span class="info-label">Department:</span>
            <span class="info-value" id="display-department">Loading...</span>
        </div>
    </div>

    <div class="chat-container">
        <p><b>Welcome! Starting your personalized AeroAstro AI assistant...</b></p>
        <div id="voiceflow-chat"></div>
    </div>

    <script type="text/javascript">
        // URL CLEANUP FUNCTION
        function cleanUrlAfterProcessing() {
            const urlParams = new URLSearchParams(window.location.search);
            
            if (urlParams.has('kerberos') || urlParams.has('authenticated') || urlParams.has('email')) {
                console.log('=== URL CLEANUP: Found parameters to clean ===');
                
                setTimeout(() => {
                    // DON'T call collectUserData again - just check window.currentUser
                    if (window.currentUser && window.currentUser.kerberos) {
                        console.log('=== URL CLEANUP: User verified, cleaning URL ===');
                        
                        const cleanUrl = window.location.origin + window.location.pathname;
                        window.history.replaceState({}, document.title, cleanUrl);
                        
                        console.log('=== URL CLEANUP: Parameters cleaned ===');
                        
                        const notification = document.createElement('div');
                        notification.style.cssText = `
                            position: fixed;
                            top: 10px;
                            right: 10px;
                            background: #28a745;
                            color: white;
                            padding: 8px 12px;
                            border-radius: 4px;
                            font-size: 12px;
                            z-index: 10000;
                            opacity: 0.9;
                        `;
                        notification.textContent = 'URL secured';
                        document.body.appendChild(notification);
                        
                        setTimeout(() => {
                            if (document.body.contains(notification)) {
                                document.body.removeChild(notification);
                            }
                        }, 3000);
                        
                    } else {
                        console.log('=== URL CLEANUP: User data not ready, keeping parameters ===');
                    }
                }, 1000);
            }
        }

        // Add this GLOBAL variable at the very top of your chatbot.html, before any functions
        window.VALIDATION_CALL_LOG = [];

        window.VALIDATION_LOCK = {
            active: false,
            result: null,
            timestamp: null
        };
        // Function to get URL parameters
        function getURLParameter(name) {
            return new URLSearchParams(window.location.search).get(name);
        }

        // Function to get stored metadata
        function getStoredMetadata() {
            try {
                const stored = localStorage.getItem('user_metadata');
                return stored ? JSON.parse(stored) : null;
            } catch (e) {
                console.error('Error parsing localStorage:', e.message);
                return null;
            }
        }
            // Add this function to your chatbot.html
        function checkAdminAccess(userData, validationResult) {
            console.log('Checking admin access for:', userData.kerberos);
            console.log('Validation result:', validationResult);
            
            const isAdmin = validationResult.isAdmin === true || 
                           validationResult.isAdmin === "true" || 
                           validationResult.isAdmin === '1';
            
            console.log('isAdmin check result:', isAdmin);
            
            if (isAdmin) {
                const adminLink = document.getElementById('adminLink');
                if (adminLink) {
                    adminLink.style.display = 'inline-block';
                    console.log('Admin button shown');
                } else {
                    console.log('Admin link element not found');
                }
            } else {
                console.log('User is not an admin');
            }
        }
        // SECURE: Collect user data (never trust authenticated parameter)
        function collectUserData() {
            console.log('Starting secure user data collection...');
            
            const urlData = {
                name: getURLParameter('name'),
                firstName: getURLParameter('firstName'),
                lastName: getURLParameter('lastName'),
                kerberos: getURLParameter('kerberos'),
                email: getURLParameter('email'),
                title: getURLParameter('title'),
                department: getURLParameter('department'),
                groups: getURLParameter('groups'),
                // SECURITY: Never trust authenticated parameter from URL
                authenticated: false
            };

            const storedData = getStoredMetadata();

            const userData = {
                name: urlData.name || (storedData && storedData.name) || 
                      (urlData.firstName && urlData.lastName ? `${urlData.firstName} ${urlData.lastName}` : '') ||
                      (storedData && storedData.firstName && storedData.lastName ? `${storedData.firstName} ${storedData.lastName}` : '') ||
                      'User',
                firstName: urlData.firstName || (storedData && storedData.firstName) || '',
                lastName: urlData.lastName || (storedData && storedData.lastName) || '',
                kerberos: urlData.kerberos || (storedData && storedData.kerberos) || '',
                email: urlData.email || (storedData && storedData.email) || '',
                title: urlData.title || (storedData && storedData.title) || '',
                department: urlData.department || (storedData && storedData.department) || '',
                groups: urlData.groups || (storedData && storedData.groups) || '',
                // CRITICAL: Authentication must be validated server-side
                authenticated: false,
                loginTime: (storedData && storedData.loginTime) || new Date().toISOString()
            };

            console.log('Collected user data (authentication pending validation):', userData);
            return userData;
        }

// Prevent duplicate validation calls
let validationInProgress = false;

// More robust duplicate prevention using promise caching
let validationPromise = null;
const VALIDATION_TIMEOUT = 10000; // 10 seconds
async function validateUserAccess(userData) {
    const cacheKey = `${userData.kerberos}-${userData.department}`;
    const now = Date.now();
    
    // Check if there's an active validation
    if (window.VALIDATION_LOCK.active) {
        console.log('‚ö†Ô∏è BLOCKED: Validation already in progress');
        // Wait for the active validation to complete
        let attempts = 0;
        while (window.VALIDATION_LOCK.active && attempts < 50) {
            await new Promise(resolve => setTimeout(resolve, 100));
            attempts++;
        }
        if (window.VALIDATION_LOCK.result) {
            console.log('‚úÖ Returning cached result from active validation');
            return window.VALIDATION_LOCK.result;
        }
    }
    
    // Check if we have a recent cached result (within 30 seconds)
    if (window.VALIDATION_LOCK.result && 
        window.VALIDATION_LOCK.timestamp && 
        (now - window.VALIDATION_LOCK.timestamp) < 30000) {
        console.log('‚úÖ Returning cached validation result (age: ' + 
            (now - window.VALIDATION_LOCK.timestamp) + 'ms)');
        return window.VALIDATION_LOCK.result;
    }
    
    console.log('üÜï Starting NEW validation');
    window.VALIDATION_LOCK.active = true;
    window.VALIDATION_LOCK.timestamp = now;
    
    try {
        const result = await performValidation(userData);
        window.VALIDATION_LOCK.result = result;
        window.VALIDATION_LOCK.active = false;
        return result;
    } catch (error) {
        window.VALIDATION_LOCK.active = false;
        throw error;
    }
}

async function performValidation(userData) {
    const callTimestamp = new Date().toISOString();
    
    console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
    console.log('üì° performValidation CALLED');
    console.log('Timestamp:', callTimestamp);
    console.log('Kerberos:', userData.kerberos);
    console.log('‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');
    
    // Log this call
    window.VALIDATION_CALL_LOG.push({
        timestamp: callTimestamp,
        function: 'performValidation',
        kerberos: userData.kerberos,
        action: 'STARTING'
    });
    
    if (!userData.kerberos) {
        console.error('‚ùå No Kerberos ID - validation failed');
        return { authenticated: false, hasAccess: false, error: 'No Kerberos ID provided' };
    }

    if (!userData.department) {
        console.error('‚ùå No department - validation failed');
        return { authenticated: false, hasAccess: false, error: 'No department information' };
    }

    console.log(`üîê Validating access: ${userData.kerberos} (${userData.department})`);
    
//const webhookUrl = 'https://hook.us2.make.com/9c74dhseqfvnj6488gtx8mg4ho8hek3y';  //101625
    const webhookUrl = 'https://hook.us2.make.com/nsevfwoyexfveb4goqoxk4eta2sadle2';  //102125
        const requestBody = {
        kerberosId: userData.kerberos,
        department: userData.department
    };
    
    console.log('üì§ Sending request to Make.com:', requestBody);
    
    // Log the fetch call
    window.VALIDATION_CALL_LOG.push({
        timestamp: new Date().toISOString(),
        function: 'performValidation',
        kerberos: userData.kerberos,
        action: 'FETCH_STARTED',
        url: webhookUrl
    });
    
    const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
        cache: 'no-store',
        mode: 'cors',
        credentials: 'omit'
    });

    // Log the response
    window.VALIDATION_CALL_LOG.push({
        timestamp: new Date().toISOString(),
        function: 'performValidation',
        kerberos: userData.kerberos,
        action: 'FETCH_COMPLETED',
        status: response.status
    });

    if (!response.ok) {
        console.error('‚ùå Validation request failed:', response.status);
        throw new Error(`Validation request failed: ${response.status}`);
    }

    const validationResult = await response.json();
    console.log('üì• Make.com validation result:', validationResult);

    // Handle various response formats
    const hasAccess = validationResult.hasAccess === true || 
                      validationResult.hasAccess === "true" || 
                      validationResult.hasAccess === 1 ||
                      validationResult.hasAccess === '1';
    
    const isFirstLogin = validationResult.isFirstLogin === true || validationResult.isFirstLogin === "true";
    const isExceptionUser = validationResult.isExceptionUser === true || validationResult.isExceptionUser === "true";
    const isAdmin = validationResult.isAdmin === true || validationResult.isAdmin === "true" || validationResult.isAdmin === 1 || validationResult.isAdmin === '1';

    console.log('‚úÖ Validation processing complete');
    
    return {
        authenticated: hasAccess,
        hasAccess: hasAccess,
        isFirstLogin: isFirstLogin,
        isExceptionUser: isExceptionUser,
        accessType: validationResult.accessType,
        isAdmin: isAdmin,
        error: null
    };
}
        // Add helper function to view the log
function showValidationLog() {
    console.log('\nüìä VALIDATION CALL LOG:');
    console.log('Total calls:', window.VALIDATION_CALL_LOG.length);
    console.table(window.VALIDATION_CALL_LOG);
    
    // Count fetch calls
    const fetchCalls = window.VALIDATION_CALL_LOG.filter(log => log.action === 'FETCH_STARTED');
    console.log('\nüéØ ACTUAL FETCH CALLS TO MAKE.COM:', fetchCalls.length);
    if (fetchCalls.length > 1) {
        console.warn('‚ö†Ô∏è MULTIPLE FETCH CALLS DETECTED!');
        console.table(fetchCalls);
    }
}

// Auto-show log after 5 seconds
setTimeout(() => {
    if (window.VALIDATION_CALL_LOG.length > 0) {
        showValidationLog();
    }
}, 5000);
        // Update user display
        function updateUserDisplay(userData) {
            if (userData.authenticated || userData.kerberos) {
                document.getElementById('display-name').textContent = userData.name || 'Not provided';
                document.getElementById('display-kerberos').textContent = userData.kerberos || 'Not provided';
                document.getElementById('display-title').textContent = userData.title || 'Not provided';
                document.getElementById('display-department').textContent = userData.department || 'Not provided';
                
                document.getElementById('user-info').classList.add('visible');
            }
        }

        // Generate userID for Voiceflow
        function generateUserID(userData) {
            const kerberos = userData.kerberos;
            
            if (kerberos) {
                return `mit-${kerberos}`;
            }
            
            let userID = localStorage.getItem('userID');
            if (!userID) {
                userID = 'user-' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('userID', userID);
            }
            return userID;
        }

        // Load Voiceflow
function loadVoiceflow(userID, userData, validationResult) {  // Add validationResult parameter
    console.log('üé¨ === LOADVOICEFLOW CALLED ===');
    console.log('Timestamp:', new Date().toISOString());
    console.log('UserID:', userID);
    console.log('UserData:', userData);
    console.log('ValidationResult:', validationResult);
    console.log('Payload being sent to Voiceflow:', {
        user_name: userData.name || '',
        user_kerberos: userData.kerberos || '',
        user_title: userData.title || '',
        user_department: userData.department || '',
        user_email: userData.email || '',
        user_firstname: userData.firstName || '',
        user_lastname: userData.lastName || '',
        user_authenticated: userData.authenticated || false,
        user_groups: Array.isArray(userData.groups) ? userData.groups.join(',') : (userData.groups || ''),
        user_logintime: userData.loginTime || '',
        is_first_login: validationResult ? validationResult.isFirstLogin : false,
        is_admin: validationResult ? validationResult.isAdmin : false
    });
    console.log('=== END LOADVOICEFLOW DIAGNOSTIC ===');
    (function(d, t) {
        var v = d.createElement(t), s = d.getElementsByTagName(t)[0];
        v.onload = function() {
                        console.log('üîß Installing API interceptor...');
            
            // Store original fetch
            const originalFetch = window.fetch;
            
            // Intercept fetch calls to capture Voiceflow API responses
window.fetch = async function(...args) {
    const response = await originalFetch.apply(this, args);
    
    // Get URL as string (handle both string and URL object)
    let url = args[0];
    const urlString = typeof url === 'string' ? url : (url?.href || url?.toString() || '');
    
    // DEBUG: Log ALL fetch calls
    console.log('üîç FETCH CALL:', urlString);
    
    // Only intercept actual interaction endpoints (not logging endpoints)
    if (urlString && 
        (urlString.includes('voiceflow.com') || urlString.includes('runtime.voiceflow.com')) &&
        !urlString.includes('webchat-log') &&
        !urlString.includes('analytics')) {
        
        console.log('üì° Voiceflow API call detected:', urlString);
        console.log('üì° Full URL details:', {
            url: urlString,
            status: response.status,
            statusText: response.statusText,
            headers: Array.from(response.headers.entries())
        });
        
        const clonedResponse = response.clone();
        
       try {
            const text = await clonedResponse.text();
            console.log('üìù Raw response text length:', text.length);
            console.log('üìù Raw response text preview:', text.substring(0, 500));
        
            if (text && text.trim().length > 0) {
                const data = JSON.parse(text);
                console.log('üì¶ API Response data:', data);
                console.log('üì¶ Data type:', typeof data);
                console.log('üì¶ Is array?', Array.isArray(data));
                
                // Only send if it's an array with content, or an object with messages
                const hasContent = (Array.isArray(data) && data.length > 0) || 
                                   (data && typeof data === 'object' && !Array.isArray(data) && Object.keys(data).length > 0);
                
                console.log('üì¶ Has content?', hasContent);
                
                if (hasContent) {
                    // Send complete API response to parent window (the tester)
                    if (window.parent && window.parent !== window) {
                        window.parent.postMessage({
                            type: 'VOICEFLOW_API_RESPONSE',
                            data: data,
                            url: urlString,
                            timestamp: new Date().toISOString()
                        }, '*');
                        console.log('‚úÖ Response forwarded to parent window');
                    }
                } else {
                    console.log('‚ö†Ô∏è Empty array or object, skipping');
                }
            } else {
                console.log('‚ö†Ô∏è Empty response body, skipping');
            }
        } catch (e) {
            console.log('‚ö†Ô∏è Could not parse API response:', e);
        }
    }  // Close the if (urlString && ...) statement
    
    return response;
};  // Close window.fetch function

// Also intercept XMLHttpRequest (in case Voiceflow uses it)
            
            // Also intercept XMLHttpRequest (in case Voiceflow uses it)
            const originalXHR = window.XMLHttpRequest;
            window.XMLHttpRequest = function() {
                const xhr = new originalXHR();
                const originalOpen = xhr.open;
                const originalSend = xhr.send;
                
                let requestURL = '';
                
                xhr.open = function(method, url) {
                    requestURL = url;
                    return originalOpen.apply(this, arguments);
                };
                
                xhr.send = function() {
                    xhr.addEventListener('load', function() {
                        if (requestURL.includes('voiceflow.com') || requestURL.includes('/interact') || requestURL.includes('/state')) {
                            console.log('üì° Voiceflow XHR call detected:', requestURL);
                            try {
                                const data = JSON.parse(xhr.responseText);
                                console.log('üì¶ XHR Response data:', data);
                                
                                if (window.parent && window.parent !== window) {
                                    window.parent.postMessage({
                                        type: 'VOICEFLOW_API_RESPONSE',
                                        data: data,
                                        url: requestURL,
                                        timestamp: new Date().toISOString()
                                    }, '*');
                                    console.log('‚úÖ XHR Response forwarded to parent window');
                                }
                            } catch (e) {
                                console.log('‚ö†Ô∏è Could not parse XHR response:', e);
                            }
                        }
                    });
                    return originalSend.apply(this, arguments);
                };
                
                return xhr;
            };
            
            console.log('‚úÖ API interceptor installed successfully');
            
            // Notify parent that chatbot is ready with interceptor
            setTimeout(() => {
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage({
                        type: 'CHATBOT_READY',
                        interceptorActive: true,
                        timestamp: new Date().toISOString()
                    }, '*');
                    console.log('üì¢ CHATBOT_READY message sent to parent');
                }
            }, 3000);

            window.voiceflow.chat.load({
                verify: { projectID: '66de313d6a0d94e1bd71c5ce' },
                url: 'https://general-runtime.voiceflow.com',
                versionID: 'production',
                userID: userID,
                launch: { 
                    event: { 
                        type: 'launch', 
                            payload: { 
                                user_name: userData.name || '',
                                user_kerberos: userData.kerberos || '',
                                user_title: userData.title || '',
                                user_department: userData.department || '',
                                user_email: userData.email || '',
                                user_firstname: userData.firstName || '',
                                user_lastname: userData.lastName || '',
                                user_authenticated: userData.authenticated || false,
                                user_groups: Array.isArray(userData.groups) ? userData.groups.join(',') : (userData.groups || ''),
                                user_logintime: userData.loginTime || '',
                                boolFirstLogin: validationResult ? validationResult.isFirstLogin : false,
                                boolIsAdmin: validationResult ? validationResult.isAdmin : false,
                                boolExceptionUser: validationResult ? validationResult.isExceptionUser : false
                            }
                    } 
                },
                assistant: {
                    persistence: 'memory'
                }
            });
            
            setTimeout(() => {
                try {
                    window.voiceflow.chat.open();
                } catch (openError) {
                    console.error('Error opening chat:', openError.message);
                }
            }, 2000);
        };
        // Intercept Voiceflow's interact method to catch responses
setTimeout(() => {
    try {
        window.voiceflow.chat.open();
    } catch (openError) {
        console.error('Error opening chat:', openError.message);
    }
}, 2000);

// Listen for Voiceflow message events
// Poll for new messages in the chat
setTimeout(() => {
    console.log('üîÑ Setting up chat state polling...');
    
    let lastMessageCount = 0;
    let pollInterval;
    
    // Function to check for new messages
        function checkForNewMessages() {
            try {
                // Try to access the chat widget's shadow DOM
                const voiceflowWidget = document.querySelector('div[class*="vfrc"]') || 
                                       document.querySelector('[id*="voiceflow"]');
                
                if (voiceflowWidget && voiceflowWidget.shadowRoot) {
                    const messages = voiceflowWidget.shadowRoot.querySelectorAll('.vfrc-message, .vfrc-system-response, [class*="message"]');
                    
                    if (messages.length > lastMessageCount) {
                        console.log(`üì¨ New messages detected! Count: ${messages.length} (was ${lastMessageCount})`);
                        
                        // Get the new messages
                        const newMessages = Array.from(messages).slice(lastMessageCount);
                        const messagesData = newMessages.map(msg => ({
                            text: msg.textContent || msg.innerText,
                            html: msg.innerHTML,
                            timestamp: new Date().toISOString()
                        }));
                        
                        console.log('üí¨ New messages:', messagesData);
                        
                        // Send to parent
                        if (window.parent && window.parent !== window) {
                            window.parent.postMessage({
                                type: 'VOICEFLOW_API_RESPONSE',
                                data: messagesData,
                                source: 'POLLING',
                                timestamp: new Date().toISOString()
                            }, '*');
                            console.log('‚úÖ Messages forwarded to parent');
                        }
                        
                        lastMessageCount = messages.length;
                    }
                }
            } catch (error) {
                console.log('‚ö†Ô∏è Error checking messages:', error.message);
            }
        }
        
        // Start polling every 500ms
        pollInterval = setInterval(checkForNewMessages, 500);
        console.log('‚úÖ Chat polling started (checking every 500ms)');
        
        // Also notify parent about the polling
        if (window.parent && window.parent !== window) {
            window.parent.postMessage({
                type: 'CHATBOT_READY',
                interceptorActive: true,
                method: 'POLLING',
                timestamp: new Date().toISOString()
            }, '*');
        }
    }, 5000);

        
        v.src = "https://cdn.voiceflow.com/widget-next/bundle.mjs"; 
        v.type = "text/javascript"; 
        s.parentNode.insertBefore(v, s);
    })(document, 'script');
}

        // SECURE: Initialize page with mandatory validation
async function initializePage() {
    console.log('=== PAGE INITIALIZATION START ===');
    console.log('Timestamp:', new Date().toISOString());
    
    const userData = collectUserData();
    console.log('User data collected:', userData.kerberos);
    
    if (!userData.kerberos) {
        console.log('No Kerberos ID found - redirecting to login');
        setTimeout(() => {
            window.location.href = 'login.html';
        }, 3000);
        return;
    }
    
    document.getElementById('display-name').textContent = 'Validating access...';
    document.getElementById('user-info').classList.add('visible');
    
    console.log('=== CALLING VALIDATION (STEP 1) ===');
    const validation = await validateUserAccess(userData);
    console.log('=== VALIDATION COMPLETED (STEP 1) ===');
    
    if (!validation.authenticated) {
        console.log('Access denied by server validation');
                
                // Show access denied page
                document.body.innerHTML = `
                    <div class="access-denied">
                        <h1>Access Denied</h1>
                        <p>You are not authorized to access this chatbot.</p>
                        <p><strong>Reason:</strong> You must be a member of the Department of Aeronautics and Astronautics or have special access granted.</p>
                        <p><strong>Your Info:</strong> ${userData.kerberos} (${userData.department || 'Unknown Department'})</p>
                        ${validation.error ? `<p><strong>Technical Details:</strong> ${validation.error}</p>` : ''}
                        <p>If you believe this is an error, please contact the administrator.</p>
                        <a href="login.html" class="retry-btn">Try Login Again</a>
                    </div>
                `;
                return;
            }
            
            console.log('Server validation successful - granting access');
            
            // Update with validated status
            userData.authenticated = true;
            userData.hasAccess = validation.hasAccess;
            userData.isFirstLogin = validation.isFirstLogin;
            userData.isExceptionUser = validation.isExceptionUser;
            
            updateUserDisplay(userData);
            const userID = generateUserID(userData);
            
            window.currentUser = userData;
            
            console.log('=== CALLING ADMIN CHECK ===');
            checkAdminAccess(userData, validation);
            
            console.log('=== CALLING URL CLEANUP ===');
            cleanUrlAfterProcessing();
            
            console.log('=== LOADING VOICEFLOW ===');
            loadVoiceflow(userID, userData, validation);  // Add validation as 3rd parameter
            
            console.log('=== PAGE INITIALIZATION COMPLETE ===');
        }

        
    // Initialize when page loads - prevent duplicate initialization
    let pageInitialized = false;

        document.addEventListener('DOMContentLoaded', function() {
        if (pageInitialized) {
            console.log('=== WARNING: DOMContentLoaded fired again, ignoring ===');
            return;
        }
        
        pageInitialized = true;
        console.log('=== DOMContentLoaded: First time, initializing page ===');
        initializePage();
    });
    </script>
</body>
</html>







































