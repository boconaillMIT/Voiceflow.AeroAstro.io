<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AeroAstro Chatbot v4.3</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .user-info {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
        }
        .user-info.visible {
            display: block;
        }
        .info-row {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 5px;
        }
        .info-label {
            font-weight: 600;
            color: #555;
        }
        .info-value {
            color: #333;
        }
        .chat-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-height: 400px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>AeroAstro Chatbot</h1>
        <p>AI Assistant for MIT's Department of Aeronautics and Astronautics</p>
    </div>

    <div class="user-info" id="user-info">
        <div class="info-row">
            <span class="info-label">Welcome:</span>
            <span class="info-value" id="display-name">Loading...</span>
        </div>
        <div class="info-row">
            <span class="info-label">Kerberos:</span>
            <span class="info-value" id="display-kerberos">Loading...</span>
        </div>
        <div class="info-row">
            <span class="info-label">Title:</span>
            <span class="info-value" id="display-title">Loading...</span>
        </div>
        <div class="info-row">
            <span class="info-label">Department:</span>
            <span class="info-value" id="display-department">Loading...</span>
        </div>
    </div>

    <div class="chat-container">
        <p><b>Welcome! Starting your personalized AeroAstro AI assistant...</b></p>
        <div id="voiceflow-chat"></div>
    </div>

    <script type="text/javascript">
        // Function to get URL parameters
        function getURLParameter(name) {
            return new URLSearchParams(window.location.search).get(name);
        }

        // Function to get stored metadata
        function getStoredMetadata() {
            try {
                const stored = localStorage.getItem('user_metadata');
                return stored ? JSON.parse(stored) : null;
            } catch (e) {
                console.error('Error parsing localStorage:', e.message);
                return null;
            }
        }

        // Collect all user data from URL params and localStorage
        function collectUserData() {
            // Get data from URL parameters first
            const urlData = {
                name: getURLParameter('name'),
                firstName: getURLParameter('firstName'),
                lastName: getURLParameter('lastName'),
                kerberos: getURLParameter('kerberos'),
                email: getURLParameter('email'),
                title: getURLParameter('title'),
                department: getURLParameter('department'),
                groups: getURLParameter('groups'),
                authenticated: getURLParameter('authenticated')
            };

            // Get data from localStorage
            const storedData = getStoredMetadata();

            // PKCE CLEANUP: Remove stale PKCE tokens if we have fresh OAuth data from URL
            const currentVerifier = localStorage.getItem('pkce_verifier');
            const currentState = localStorage.getItem('pkce_state');
            
            if (urlData.authenticated === 'true' && urlData.kerberos) {
                if (currentVerifier || currentState) {
                    localStorage.removeItem('pkce_verifier');
                    localStorage.removeItem('pkce_state');
                    localStorage.removeItem('oauth_state');
                }
            } else if (currentVerifier || currentState) {
                // Check if PKCE tokens are old (more than 10 minutes)
                const pkceTimestamp = localStorage.getItem('pkce_timestamp');
                if (pkceTimestamp) {
                    const age = Date.now() - parseInt(pkceTimestamp);
                    if (age > 600000) { // 10 minutes
                        localStorage.removeItem('pkce_verifier');
                        localStorage.removeItem('pkce_state');
                        localStorage.removeItem('oauth_state');
                        localStorage.removeItem('pkce_timestamp');
                    }
                } else {
                    // No timestamp means really old tokens, clear them
                    localStorage.removeItem('pkce_verifier');
                    localStorage.removeItem('pkce_state');
                    localStorage.removeItem('oauth_state');
                }
            }

            // Merge data (URL params take precedence over localStorage)
            const userData = {
                name: urlData.name || (storedData && storedData.name) || 
                      (urlData.firstName && urlData.lastName ? `${urlData.firstName} ${urlData.lastName}` : '') ||
                      (storedData && storedData.firstName && storedData.lastName ? `${storedData.firstName} ${storedData.lastName}` : '') ||
                      'User',
                firstName: urlData.firstName || (storedData && storedData.firstName) || '',
                lastName: urlData.lastName || (storedData && storedData.lastName) || '',
                kerberos: urlData.kerberos || (storedData && storedData.kerberos) || '',
                email: urlData.email || (storedData && storedData.email) || '',
                title: urlData.title || (storedData && storedData.title) || '',
                department: urlData.department || (storedData && storedData.department) || '',
                groups: urlData.groups || (storedData && storedData.groups) || '',
                authenticated: urlData.authenticated === 'true' || 
                              !!(storedData && storedData.kerberos), // Force true if we have kerberos
                loginTime: (storedData && storedData.loginTime) || new Date().toISOString()
            };

            return userData;
        }

        // Update the display with user information
        function updateUserDisplay(userData) {
            if (userData.authenticated || userData.kerberos) {
                document.getElementById('display-name').textContent = userData.name || 'Not provided';
                document.getElementById('display-kerberos').textContent = userData.kerberos || 'Not provided';
                document.getElementById('display-title').textContent = userData.title || 'Not provided';
                document.getElementById('display-department').textContent = userData.department || 'Not provided';
                
                document.getElementById('user-info').classList.add('visible');
            }
        }

        // Generate userID for Voiceflow with URL fallback
        function generateUserID(userData) {
            // Get kerberos from URL parameters directly as backup
            const urlKerberos = new URLSearchParams(window.location.search).get('kerberos');
            const kerberos = userData.kerberos || urlKerberos;
            
            if (kerberos) {
                return `mit-${kerberos}`;
            }
            
            let userID = localStorage.getItem('userID');
            if (!userID) {
                userID = 'user-' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('userID', userID);
            }
            return userID;
        }

        // Add communication bridge for automated testing
        function setupTestingBridge() {
            // Only set up if we're in an iframe (being used by the tester)
            if (window.parent !== window) {
                console.log('ðŸ”§ NEW VERSION v4.0 - Setting up testing bridge for automated testing');
                
                // Method 1: Intercept Voiceflow API calls with proper SSE handling
                if (!window.originalFetch) {
                    window.originalFetch = window.fetch;
                    window.fetch = function(...args) {
                        return window.originalFetch.apply(this, args).then(response => {
                            const url = args[0];
                            if (typeof url === 'string' && url.includes('general-runtime.voiceflow.com')) {
                                console.log('ðŸŒ v4.0 Intercepted Voiceflow API call:', url);
                                
                                // Check if this is a streaming response
                                if (url.includes('/stream')) {
                                    console.log('ðŸ“¡ v4.0 Detected streaming response - setting up SSE parser');
                                    // Clone response to read the stream
                                    const clonedResponse = response.clone();
                                    parseSSEStream(clonedResponse);
                                } else {
                                    console.log('ðŸ“„ v4.0 Non-streaming response - using JSON parser');
                                    const clonedResponse = response.clone();
                                    clonedResponse.json().then(data => {
                                        console.log('ðŸ“„ v4.0 JSON response:', data);
                                        extractAndSendBotMessage(data);
                                    }).catch(e => console.log('âŒ v4.0 JSON parse error:', e));
                                }
                            }
                            return response;
                        });
                    };
                }
                
                // Parse Server-Sent Events stream
                async function parseSSEStream(response) {
                    console.log('ðŸ”„ v4.0 Starting SSE stream parsing...');
                    try {
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) {
                                console.log('âœ… v4.0 SSE stream ended');
                                break;
                            }
                            
                            buffer += decoder.decode(value, { stream: true });
                            
                            // Process complete SSE messages
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // Keep incomplete line in buffer
                            
                            let eventData = {};
                            let eventType = '';
                            
                            for (const line of lines) {
                                if (line.startsWith('event: ')) {
                                    eventType = line.substring(7).trim();
                                } else if (line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.substring(6));
                                        eventData = data;
                                        console.log(`ðŸŽ¯ v4.0 SSE Event [${eventType}]:`, data);
                                        
                                        // Extract bot message from this event
                                        extractAndSendBotMessage(data);
                                    } catch (e) {
                                        console.log('âš ï¸ v4.0 Error parsing SSE data line:', line.substring(0, 50) + '...', e);
                                    }
                                } else if (line.trim() === '') {
                                    // Empty line marks end of event
                                    continue;
                                }
                            }
                        }
                    } catch (error) {
                        console.error('âŒ v4.0 Error reading SSE stream:', error);
                    }
                }
                
                // Extract bot message from Voiceflow response
                function extractAndSendBotMessage(data) {
                    console.log('ðŸ” v4.0 Analyzing response for bot message:', data);
                    let botMessage = null;
                    
                    try {
                        // Method 1: Direct trace object (for individual SSE events)
                        if (data.type === 'speak' && data.payload && data.payload.message) {
                            botMessage = data.payload.message;
                            console.log('ðŸ’¬ v4.0 Found speak message:', botMessage);
                        } else if (data.type === 'text' && data.payload && data.payload.message) {
                            botMessage = data.payload.message;
                            console.log('ðŸ’¬ v4.0 Found text message:', botMessage);
                        }
                        
                        // Method 2: Check for trace array (for batch responses)
                        if (!botMessage && data.trace && Array.isArray(data.trace)) {
                            console.log('ðŸ“‹ v4.0 Found trace array with', data.trace.length, 'items');
                            for (const trace of data.trace) {
                                if (trace.type === 'speak' && trace.payload && trace.payload.message) {
                                    botMessage = trace.payload.message;
                                    console.log('ðŸ’¬ v4.0 Found speak in trace:', botMessage);
                                    break;
                                } else if (trace.type === 'text' && trace.payload && trace.payload.message) {
                                    botMessage = trace.payload.message;
                                    console.log('ðŸ’¬ v4.0 Found text in trace:', botMessage);
                                    break;
                                }
                            }
                        }
                        
                        // Method 3: Direct message fields
                        if (!botMessage && data.message) {
                            botMessage = data.message;
                            console.log('ðŸ’¬ v4.0 Found direct message:', botMessage);
                        }
                        
                        if (botMessage) {
                            console.log('âœ… v4.0 SENDING BOT MESSAGE TO TESTER:', botMessage);
                            // Send to parent window
                            window.parent.postMessage({
                                type: 'voiceflow_response',
                                message: botMessage
                            }, '*');
                        } else {
                            console.log('ðŸ¤· v4.0 No bot message found in this data');
                        }
                        
                    } catch (error) {
                        console.error('âŒ v4.0 Error extracting message:', error);
                    }
                }
                
                // Method 2: DOM observer as fallback
                function observeChatWidget() {
                    let lastMessageCount = 0;
                    
                    function checkForNewMessages() {
                        const messageElements = document.querySelectorAll('[class*="message"], [class*="chat"], [class*="bubble"], div[class*="vfrc"]');
                        
                        if (messageElements.length > lastMessageCount) {
                            console.log(`ðŸ‘€ v4.0 DOM: Found ${messageElements.length} total messages (was ${lastMessageCount})`);
                            
                            // Check the latest messages
                            for (let i = lastMessageCount; i < messageElements.length; i++) {
                                const element = messageElements[i];
                                const text = element.textContent.trim();
                                
                                if (text && text.length > 5 && !text.toLowerCase().includes('user') && !text.includes('Send message')) {
                                    console.log('ðŸ’¬ v4.0 DOM: Potential bot message:', text);
                                    window.parent.postMessage({
                                        type: 'voiceflow_response',
                                        message: text
                                    }, '*');
                                }
                            }
                            
                            lastMessageCount = messageElements.length;
                        }
                    }
                    
                    // Check every 3 seconds
                    setInterval(checkForNewMessages, 3000);
                    console.log('ðŸ‘ï¸ v4.0 DOM observer setup complete (polling every 3s)');
                }
                
                // Start DOM observer after delay
                setTimeout(observeChatWidget, 5000);
                
                console.log('ðŸŽ‰ v4.0 Testing bridge setup complete!');
            }
        }

        // Load Voiceflow and set OAuth variables
        function loadVoiceflow(userID, userData) {
            (function(d, t) {
                var v = d.createElement(t), s = d.getElementsByTagName(t)[0];
                v.onload = function() {
                    // Load Voiceflow with launch payload containing user variables
                    window.voiceflow.chat.load({
                        verify: { projectID: '66de313d6a0d94e1bd71c5ce' },
                        url: 'https://general-runtime.voiceflow.com',
                        versionID: 'production',
                        userID: userID,
                        launch: { 
                            event: { 
                                type: 'launch', 
                                payload: { 
                                    user_name: userData.name || '',
                                    user_kerberos: userData.kerberos || '',
                                    user_title: userData.title || '',
                                    user_department: userData.department || '',
                                    user_email: userData.email || '',
                                    user_authenticated: userData.authenticated || false
                                } 
                            } 
                        },
                        assistant: {
                            persistence: 'memory'
                        },
                        voice: {
                            url: "https://runtime-api.voiceflow.com"
                        }
                    });
                    
                    // Open chat after load completes
                    setTimeout(() => {
                        try {
                            window.voiceflow.chat.open();
                            // Set up testing bridge after chat opens
                            setupTestingBridge();
                        } catch (openError) {
                            console.error('Error opening chat:', openError.message);
                        }
                    }, 2000);
                };
                
                v.onerror = function() {
                    console.error('Error loading Voiceflow script');
                };
                
                v.src = "https://cdn.voiceflow.com/widget-next/bundle.mjs"; 
                v.type = "text/javascript"; 
                s.parentNode.insertBefore(v, s);
            })(document, 'script');
        }

        // Initialize the page
        function initializePage() {
            const userData = collectUserData();
            
            // Check if user has valid OAuth data
            if (!userData.authenticated && !userData.kerberos) {
                setTimeout(() => {
                    window.location.href = 'login.html';
                }, 3000);
                return;
            }
            
            updateUserDisplay(userData);
            const userID = generateUserID(userData);
            
            window.currentUser = userData;
            
            loadVoiceflow(userID, userData);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializePage();
        });
    </script>
</body>
</html>
