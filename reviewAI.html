<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Review AI KB Submissions - AeroAstro Bot</title>
   <style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
        color: #333;
        line-height: 1.6;
        min-height: 100vh;
    }
    
    .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        background: white;
        min-height: 100vh;
    }
    
    header {
        background: linear-gradient(135deg, #003d5c 0%, #1e5a7a 50%, #4a90b8 100%);
        color: white;
        padding: 30px 40px;
        margin: -20px -20px 30px -20px;
        border-bottom: 4px solid #003d5c;
        position: relative;
        overflow: hidden;
    }
    

    
    h1 {
        font-size: 2.2em;
        font-weight: 600;
        margin-bottom: 10px;
        letter-spacing: -0.5px;
        position: relative;
        z-index: 1;
    }
    
    .subtitle {
        font-size: 1.1em;
        opacity: 0.95;
        font-weight: 300;
        position: relative;
        z-index: 1;
    }
    
    .controls {
        display: flex;
        gap: 20px;
        align-items: center;
        margin-bottom: 25px;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 8px;
        border-left: 4px solid #003d5c;
        flex-wrap: wrap;
    }
    
    .controls > * {
        margin-right: 10px;
    }
    
    label {
        font-weight: 600;
        color: #2c3e50;
        font-size: 0.95em;
        white-space: nowrap;
    }
    
    select {
        padding: 10px 15px;
        border: 2px solid #ddd;
        border-radius: 6px;
        font-size: 0.95em;
        background: white;
        cursor: pointer;
        transition: all 0.3s ease;
        min-width: 150px;
    }
    
    select:hover {
        border-color: #003d5c;
    }
    
    select:focus {
        outline: none;
        border-color: #003d5c;
        box-shadow: 0 0 0 3px rgba(0, 61, 92, 0.1);
    }
    
    .btn {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.95em;
        font-weight: 500;
        transition: all 0.3s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        white-space: nowrap;
    }
    
    .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .btn:active {
        transform: translateY(0);
    }
    
    .btn-primary {
        background: #003d5c;
        color: white;
    }
    
    .btn-primary:hover {
        background: #002a40;
    }
    
    .btn-success {
        background: #27ae60;
        color: white;
    }
    
    .btn-success:hover {
        background: #229954;
    }
    
    .btn-danger {
        background: #e74c3c;
        color: white;
    }
    
    .btn-danger:hover {
        background: #c0392b;
    }
    
    .btn-secondary {
        background: #95a5a6;
        color: white;
    }
    
    .btn-secondary:hover {
        background: #7f8c8d;
    }
    
    table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        background: white;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }
    
    thead {
        background: linear-gradient(135deg, #003d5c 0%, #1e5a7a 50%, #4a90b8 100%);
        color: white;
    }
    
    th {
        padding: 16px 12px;
        text-align: left;
        font-weight: 600;
        font-size: 0.9em;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    tbody tr {
        border-bottom: 1px solid #ecf0f1;
        transition: all 0.2s ease;
    }
    
    tbody tr:hover {
        background: #f8f9fa;
        transform: scale(1.01);
    }
    
    td {
        padding: 14px 12px;
        font-size: 0.95em;
    }
    
    .preview {
        max-width: 300px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        color: #7f8c8d;
        font-size: 0.9em;
    }
    
    .badge {
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 0.85em;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.3px;
        display: inline-block;
    }
    
    .badge-pending {
        background: #fff3cd;
        color: #856404;
    }
    
    .badge-approved {
        background: #d4edda;
        color: #155724;
    }
    
    .badge-rejected {
        background: #f8d7da;
        color: #721c24;
    }
    
    /* Modal Styles */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    .modal-content {
        background: white;
        margin: 3% auto;
        padding: 0;
        width: 90%;
        max-width: 900px;
        border-radius: 12px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        animation: slideDown 0.3s ease;
        max-height: 90vh;
        overflow-y: auto;
        border: 3px solid #003d5c;
    }
    
    @keyframes slideDown {
        from { 
            transform: translateY(-50px);
            opacity:
</head>



<body>

    <div class="container">
        <a href="admin.html" class="back-link">‚Üê Back to Admin Panel</a>
        <div class="header">
            <h1>Review AI Knowledge Base Submissions</h1>
            <p>Review and approve/reject pending submissions to the AeroAstro AI Knowledge Base</p>
        </div>
        <div id="statusMessage" class="status-message"></div>
        <div id="loading" class="loading"><div class="spinner"></div><p>Loading submissions...</p></div>
        <div class="filter-section">
            <div class="filter-group">
                <label>Status Filter:</label>
                <select id="statusFilter" onchange="loadSubmissions()">
                    <option value="Pending">Pending Only</option>
                    <option value="All">All Submissions</option>
                    <option value="Approved">Approved</option>
                    <option value="Rejected">Rejected</option>
                </select>
            </div>
            <button class="btn" onclick="loadSubmissions()">üîÑ Refresh</button>
        </div>
        <div id="bulkActionsBar" class="bulk-actions">
            <span class="bulk-actions-text"><span id="selectedCount">0</span> selected</span>
            <button class="btn btn-success" onclick="bulkApprove()">‚úì Approve Selected</button>
            <button class="btn btn-danger" onclick="bulkReject()">‚úó Reject Selected</button>
            <button class="btn" onclick="clearSelection()">Clear Selection</button>
        </div>
        <table class="submissions-table">
            <thead>
                <tr>
                    <th class="checkbox-col"><input type="checkbox" id="selectAll" onchange="toggleSelectAll()" title="Select All"></th>
                    <th>Date</th><th>From</th><th>Subject</th><th>Preview</th><th>Attachments</th><th>Status</th><th>Actions</th>
                </tr>
            </thead>
            <tbody id="submissionsTableBody"></tbody>
        </table>
    </div>
    <div id="reviewModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><span class="close" onclick="closeModal()">&times;</span><h2>Review Submission</h2></div>
            <div id="modalBody"></div>
            <div class="actions-section">
                <button class="btn btn-success" onclick="approveSubmission()" style="font-size: 16px; padding: 12px 24px;">‚úì Approve & Upload to KB</button>
                <button class="btn btn-danger" onclick="showRejectForm()" style="font-size: 16px; padding: 12px 24px;">‚úó Reject</button>
                <button class="btn" onclick="closeModal()" style="font-size: 16px; padding: 12px 24px;">Cancel</button>
            </div>
            <div id="rejectForm" style="display:none; margin-top: 20px;">
                <h3>Rejection Notes</h3>
                <textarea id="rejectNotes" class="reject-notes" placeholder="Enter reason for rejection (optional)..."></textarea>
                <button class="btn btn-danger" onclick="confirmReject()">Confirm Rejection</button>
                <button class="btn" onclick="hideRejectForm()">Cancel</button>
            </div>
        </div>
    </div>
    <script>
        const QUICKBASE_CONFIG = {realm: 'mit.quickbase.com', userToken: 'b4bqn2_bkcg_0_cjj8hwibg9qrcyx9fm2qiqa5h', appId: 'buuhxhtmv', pendingTableId: 'bvhhfa58i', userTableId: 'bve87f9um'};
    const MAKECOM_WEBHOOK = 'https://hook.us2.make.com/1hp1aj8tqsxkveen4l5ig8b3117r35sw';

const REJECT_ATTACHMENT_WEBHOOK = 'https://hook.us2.make.com/8hvpcefzwsmhju7ch2h46xlknqfg1fyn';
    let currentUser = '';
    let currentSubmission = null;
       // checks to see if user has administrator access in quickbase
      async function checkAuth() {
    try {
        const storedData = localStorage.getItem('user_metadata');
        if (!storedData) {
            showMessage('No authentication data found. Please login to the chatbot first.', 'error');
            setTimeout(() => {
                window.location.href = 'login.html';
            }, 3000);
            return false;
        }
        
        const userData = JSON.parse(storedData);
        currentUser = userData.kerberos;
        console.log('Checking admin access for:', currentUser);
        
        // Show loading while checking admin status
        showMessage('Verifying administrator access...', 'info');
        
        // Call Make.com webhook to validate admin status
        const response = await fetch('https://hook.us2.make.com/nsevfwoyexfveb4goqoxk4eta2sadle2', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                kerberosId: userData.kerberos,
                department: userData.department || ''
            })
        });
        
        if (!response.ok) {
            throw new Error('Validation failed');
        }
        
        // Check what we're actually getting back
        const responseText = await response.text();
        console.log('Raw response from Make.com:', responseText);
        
        let validation;
        try {
            validation = JSON.parse(responseText);
        } catch (e) {
            console.error('Failed to parse response:', responseText);
            if (responseText === 'Accepted') {
                throw new Error('Make.com webhook returned "Accepted" instead of user data - check webhook configuration');
            }
            throw new Error('Invalid response format from validation service');
        }
        
        console.log('Admin validation result:', validation);
        
        // Rest of your validation logic continues here...
        const isAdmin = validation.isAdmin === true || 
                       validation.isAdmin === "true" || 
                       validation.isAdmin === '1';
        
        const hasAccess = validation.hasAccess === true || 
                         validation.hasAccess === "true" || 
                         validation.hasAccess === 1 ||
                         validation.hasAccess === '1';
        
        if (!hasAccess) {
            showMessage('Access denied. You are not authorized to use this system.', 'error');
            setTimeout(() => {
                window.location.href = 'login.html';
            }, 3000);
            return false;
        }
        
        if (!isAdmin) {
            showMessage('Access denied. Administrator privileges required.', 'error');
            document.body.innerHTML = `
                <div class="container">
                    <div class="header" style="border-color: #e74c3c;">
                        <h1 style="color: #e74c3c;">Access Denied</h1>
                    </div>
                    <div style="text-align: center; padding: 40px;">
                        <h2>Administrator Access Required</h2>
                        <p>This page is restricted to administrators only.</p>
                        <p>User: <strong>${currentUser}</strong></p>
                        <p style="margin-top: 30px;">
                            <a href="chatbot.html" class="btn">Return to Chatbot</a>
                            <a href="login.html" class="btn">Login as Different User</a>
                        </p>
                    </div>
                </div>
            `;
            return false;
        }
        
        console.log('Admin access granted for:', currentUser);
        showMessage('Administrator access verified', 'success');
        return true;
        
    } catch (error) {
        console.error('Auth error:', error);
        showMessage('Authentication error: ' + error.message, 'error');
        setTimeout(() => {
            window.location.href = 'login.html';
        }, 3000);
        return false;
    }
}
        
        // Update the page initialization to properly handle auth failure
        document.addEventListener('DOMContentLoaded', async function() {
            const isAuthenticated = await checkAuth();
            if (isAuthenticated) {
                loadSubmissions();
            }
            // If not authenticated, the checkAuth function will handle the redirect
        });
       // Function to load attachments for a record
async function loadAttachments(recordId) {
    const attachmentsDiv = document.getElementById(`attachments-${recordId}`);
    attachmentsDiv.innerHTML = 'Loading attachments...';
    
    // Query QuickBase for attachment records with parent_record = recordId
    const query = {
        "from": "bvhhfa58i", // Your table ID
        "select": [3, 18], // Record ID and filename field
        "where": `{parent_record.EX.'${recordId}'}`
    };
    
    const response = await fetch('https://api.quickbase.com/v1/records/query', {
        method: 'POST',
        headers: {
            'QB-Realm-Hostname': 'mit.quickbase.com',
            'Authorization': 'QB-USER-TOKEN ' + localStorage.getItem('qb_token'),
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(query)
    });
    
    const data = await response.json();
    displayAttachments(recordId, data.data);
}

// Function to display attachments with approve/reject buttons
function displayAttachments(recordId, attachments) {
    const attachmentsDiv = document.getElementById(`attachments-${recordId}`);
    
    if (attachments.length === 0) {
        attachmentsDiv.innerHTML = '<p>No attachments found</p>';
        return;
    }
    
    let html = '<h4>Attachments:</h4><div class="attachment-list">';
    
    attachments.forEach(att => {
        const filename = att[18].value; // Assuming field 18 has the filename
        const attachmentRecordId = att[3].value;
        
        // Extract just the filename without QB prefix
        const displayName = filename.replace(/.*QB\d+_/, '');
        
        html += `
            <div class="attachment-item" id="att-${attachmentRecordId}">
                <span class="filename">${displayName}</span>
                <div class="attachment-actions">
                    <button onclick="viewAttachment('${filename}')" class="btn-view">View</button>
                    <button onclick="approveAttachment('${attachmentRecordId}', '${filename}')" class="btn-approve">Approve</button>
                    <button onclick="rejectAttachment('${attachmentRecordId}', '${filename}')" class="btn-reject">Reject</button>
                    <span class="status"></span>
                </div>
            </div>
        `;
    });
    
    html += '</div>';
    attachmentsDiv.innerHTML = html;
}

// Function to view attachment in Google Drive
async function viewAttachmentFile(filename) {
    try {
        showLoading(true);
        const response = await fetch(`https://hook.us2.make.com/fcc8ag4lhtfvlegf87o13y64ruqkr7w8?filename=${encodeURIComponent(filename)}`);
        const data = await response.json();
        
        if (data.url) {
            window.open(data.url, '_blank');
            showMessage('Opening file in Google Drive...', 'success');
        } else {
            showMessage('Could not get file URL', 'error');
        }
    } catch (error) {
        console.error('Error viewing file:', error);
        showMessage('Error opening file: ' + error.message, 'error');
    } finally {
        showLoading(false);
    }
}

// Function to approve attachment
async function approveAttachment(attachmentRecordId, filename) {
    const statusSpan = document.querySelector(`#att-${attachmentRecordId} .status`);
    statusSpan.textContent = 'Processing...';
    
    // Call Make.com webhook to upload to Voiceflow
    const response = await fetch('https://hook.us2.make.com/ku8z97wsy6yrti8iwjapb8d17ef99kfe', {
        method: 'POST',
        body: JSON.stringify({
            recordId: attachmentRecordId,
            filename: filename
        })
    });
    
    if (response.ok) {
        statusSpan.textContent = '‚úì Approved';
        statusSpan.style.color = 'green';
        document.querySelector(`#att-${attachmentRecordId} .btn-approve`).disabled = true;
        document.querySelector(`#att-${attachmentRecordId} .btn-reject`).disabled = true;
        
        // Update QuickBase record status
        updateAttachmentStatus(attachmentRecordId, 'approved');
    }
}

// Function to reject attachment  
async function rejectAttachment(attachmentRecordId, filename) {
    const statusSpan = document.querySelector(`#att-${attachmentRecordId} .status`);
    
    if (confirm('Are you sure you want to reject this attachment?')) {
        statusSpan.textContent = 'Rejecting...';
        
        // Update QuickBase record status
        await updateAttachmentStatus(attachmentRecordId, 'rejected');
        
        statusSpan.textContent = '‚úó Rejected';
        statusSpan.style.color = 'red';
        document.querySelector(`#att-${attachmentRecordId} .btn-approve`).disabled = true;
        document.querySelector(`#att-${attachmentRecordId} .btn-reject`).disabled = true;
    }
}

// Update attachment status in QuickBase
async function updateAttachmentStatus(recordId, status) {
    const update = {
        "to": "bvhhfa58i",
        "data": [{
            "3": {"value": recordId},
            "status": {"value": status} // Add a status field to your QB table
        }]
    };
    
    await fetch('https://api.quickbase.com/v1/records', {
        method: 'POST',
        headers: {
            'QB-Realm-Hostname': 'mit.quickbase.com',
            'Authorization': 'QB-USER-TOKEN ' + localStorage.getItem('qb_token'),
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(update)
    });
}

        async function makeQuickBaseRequest(method, endpoint, body) {const url = `https://api.quickbase.com/v1/${endpoint}`; const headers = {'QB-Realm-Hostname': QUICKBASE_CONFIG.realm, 'Authorization': `QB-USER-TOKEN ${QUICKBASE_CONFIG.userToken}`, 'Content-Type': 'application/json'}; const response = await fetch(url, {method: method, headers: headers, body: body ? JSON.stringify(body) : null}); if (!response.ok) {const errorText = await response.text(); throw new Error(`QuickBase error: ${response.status} - ${errorText}`);} return await response.json();}
      async function loadSubmissions() {
    showLoading(true);
    try {
        const statusFilter = document.getElementById('statusFilter').value;
        const queryBody = {
            from: QUICKBASE_CONFIG.pendingTableId,
            select: [3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 18, 108], // Added Field 18 (filename) and 108 (attachment count)
            options: {
                orderBy: [{ fieldId: 10, order: 'DESC' }]
            }
        };
        
        if (statusFilter !== 'All') {
            queryBody.where = `{11.EX.'${statusFilter}'}`;
        }
        
        const response = await makeQuickBaseRequest('POST', 'records/query', queryBody);
        displaySubmissions(response.data);
        showMessage(`Loaded ${response.data.length} submission(s)`, 'success');
    } catch (error) {
        console.error('Load error:', error);
        showMessage('Error loading submissions: ' + error.message, 'error');
    } finally {
        showLoading(false);
    }
}   
    function displaySubmissions(submissions) {
    const tbody = document.getElementById('submissionsTableBody');
    tbody.innerHTML = '';
    
    if (submissions.length === 0) {
        tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; padding: 20px;">No submissions found</td></tr>';
        return;
    }
    
    submissions.forEach(sub => {
        const row = tbody.insertRow();
        const date = new Date(sub[10]?.value);
        
        const filename = sub[18]?.value || '';
        const isAttachment = filename !== '';
        
        const subjectDisplay = isAttachment ? 'üìé Attachment: ' + filename : (sub[8]?.value || 'No Subject');
        
        const attachmentCount = isAttachment ? 'N/A' : (sub[12]?.value ? String(sub[13]?.value || 0) + ' file(s)' : '0 file(s)');
        
        let preview = 'No content';
        try {
            if (sub[9]?.value) {
                preview = atob(sub[9].value).substring(0, 100) + '...';
            }
        } catch (e) {
            preview = sub[9]?.value ? sub[9].value.substring(0, 100) + '...' : 'No content';
        }
        
        const status = sub[11]?.value || 'Pending';
        const recordId = sub[3].value;
        const isDisabled = status !== 'Pending' ? 'disabled' : '';
        
        row.innerHTML = '<td class="checkbox-col"><input type="checkbox" class="submission-checkbox" data-record-id="' + recordId + '" onchange="updateBulkActions()" ' + isDisabled + '></td><td>' + date.toLocaleDateString() + ' ' + date.toLocaleTimeString() + '</td><td>' + (sub[6]?.value || 'Unknown') + '</td><td>' + subjectDisplay + '</td><td class="preview">' + preview + '</td><td>' + attachmentCount + '</td><td><span class="badge badge-' + status.toLowerCase() + '">' + status + '</span></td><td><button class="btn btn-small" onclick="viewSubmission(' + recordId + ')">Review</button></td>';
    });
}   
                    
async function viewSubmission(recordId) {
    try {
        showLoading(true);
        const response = await makeQuickBaseRequest('POST', 'records/query', {
            from: QUICKBASE_CONFIG.pendingTableId,
            select: [3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 18],
            where: `{3.EX.${recordId}}`
        });

        if (response.data.length === 0) {
            showMessage('Submission not found', 'error');
            return;
        }

        const submission = response.data[0];
        const filename = submission[18]?.value || '';
        const isAttachment = filename !== '';
        
        let detailsHtml = '<div class="submission-details"><div class="detail-row"><div class="detail-col"><strong>From:</strong><br>' + (submission[6]?.value || 'Unknown') + '</div><div class="detail-col"><strong>Kerberos:</strong><br>' + (submission[7]?.value || 'Unknown') + '</div><div class="detail-col"><strong>Date:</strong><br>' + new Date(submission[10]?.value).toLocaleString() + '</div><div class="detail-col"><strong>Status:</strong><br><span class="badge badge-' + (submission[11]?.value || 'pending').toLowerCase() + '">' + (submission[11]?.value || 'Pending') + '</span></div></div><div class="detail-row"><div class="detail-col-full"><strong>Subject:</strong><br>' + (submission[8]?.value || 'No Subject') + '</div></div>';

        if (isAttachment) {
            detailsHtml += '<div class="detail-row"><div class="detail-col-full"><strong>Attachment Type:</strong><br>üìé PDF Document</div></div><div class="detail-row"><div class="detail-col-full"><strong>Filename:</strong><br>' + filename + '</div></div><div class="detail-row"><div class="detail-col-full"><em>This is an attachment file. Click "Approve & Upload to KB" to upload the PDF to Voiceflow.</em></div></div>';
        } else {
            detailsHtml += '<div class="detail-row"><div class="detail-col-full"><strong>Attachments:</strong><br>' + (submission[12]?.value ? String(submission[13]?.value || 0) + ' file(s)' : 'None') + '</div></div><div class="detail-row"><div class="detail-col-full"><strong>Email Body:</strong> <em style="color: #666;">(editable - make changes before approving)</em><br><textarea id="emailBodyText" class="email-body-edit" rows="15">';
            
            try {
                if (submission[9]?.value) {
                    detailsHtml += atob(submission[9].value);
                } else {
                    detailsHtml += 'No content';
                }
            } catch (e) {
                detailsHtml += submission[9]?.value || 'No content';
            }
            
            detailsHtml += '</textarea></div></div>';
        }

       if (isAttachment) {
            detailsHtml += '<div class="button-group"><button class="btn btn-primary" onclick="viewAttachmentFile(\'' + filename.replace(/'/g, "\\'") + '\')">üëÅÔ∏è View File</button><button class="btn btn-success" onclick="approveSubmission(' + recordId + ', ' + isAttachment + ', \'' + filename.replace(/'/g, "\\'") + '\')">‚úì Approve & Upload to KB</button><button class="btn btn-danger" onclick="rejectSubmission(' + recordId + ')">‚úó Reject</button><button class="btn btn-secondary" onclick="closeModal()">Cancel</button></div></div>';
        } else {
            detailsHtml += '<div class="button-group"><button class="btn btn-success" onclick="approveSubmission(' + recordId + ', ' + isAttachment + ', \'' + filename.replace(/'/g, "\\'") + '\')">‚úì Approve & Upload to KB</button><button class="btn btn-danger" onclick="rejectSubmission(' + recordId + ')">‚úó Reject</button><button class="btn btn-secondary" onclick="closeModal()">Cancel</button></div></div>';
        }
        
        document.getElementById('submissionDetails').innerHTML = detailsHtml;
        document.getElementById('detailModal').style.display = 'block';
    } catch (error) {
        console.error('Error:', error);
        showMessage('Error loading submission: ' + error.message, 'error');
    } finally {
        showLoading(false);
    }
}   
        
        function displaySubmissionDetails(sub) {let emailBody = 'No email body'; try {if (sub[9]?.value) {emailBody = atob(sub[9].value);}} catch (e) {emailBody = sub[9]?.value || 'No email body'; console.warn('Failed to decode base64 email body:', e);} const date = new Date(sub[10]?.value); let attachmentInfo = []; let attachmentsHtml = '<span style="color: #7f8c8d;">None</span>'; if (sub[14]?.value && sub[14].value !== "27" && sub[14].value !== "[]") {try {attachmentInfo = JSON.parse(sub[14].value); if (attachmentInfo.length > 0) {attachmentsHtml = '<ul class="attachment-list">'; attachmentInfo.forEach(att => {attachmentsHtml += `<li>üìé <a href="${att.driveUrl}" target="_blank">${att.fileName}</a></li>`;}); attachmentsHtml += '</ul>';}} catch (e) {console.warn('Could not parse attachment info:', e); if (sub[12]?.value && sub[13]?.value > 0) {attachmentsHtml = `<span style="color: #f39c12;">üìé ${sub[13].value} attachment(s) - Will be uploaded when approved</span>`;}}} else if (sub[12]?.value && sub[13]?.value > 0) {attachmentsHtml = `<span style="color: #f39c12;">üìé ${sub[13].value} attachment(s) - Will be uploaded when approved</span>`;} document.getElementById('modalBody').innerHTML = `<div class="detail-grid" style="grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px; margin-bottom: 15px;"><div class="detail-item"><label>From:</label><div class="value" style="font-size: 13px;">${sub[6]?.value || 'Unknown'}</div></div><div class="detail-item"><label>Kerberos:</label><div class="value" style="font-size: 13px;">${sub[7]?.value || 'N/A'}</div></div><div class="detail-item"><label>Date:</label><div class="value" style="font-size: 13px;">${date.toLocaleDateString()} ${date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div></div><div class="detail-item"><label>Status:</label><div class="value"><span class="badge badge-${(sub[11]?.value || 'Pending').toLowerCase()}">${sub[11]?.value || 'Pending'}</span></div></div></div><div class="detail-grid" style="grid-template-columns: 2fr 1fr; gap: 10px; margin-bottom: 15px;"><div style="padding: 10px; background-color: #f8f9fa; border-radius: 4px;"><label style="font-weight: bold; color: #2c3e50; display: block; margin-bottom: 5px; font-size: 12px;">Subject:</label><div style="color: #34495e; font-size: 14px;">${sub[8]?.value || 'No Subject'}</div></div><div style="padding: 10px; background-color: #f8f9fa; border-radius: 4px;"><label style="font-weight: bold; color: #2c3e50; display: block; margin-bottom: 5px; font-size: 12px;">Attachments:</label><div style="color: #34495e; font-size: 13px;">${attachmentsHtml}</div></div></div><div class="email-body-container"><label style="font-weight: bold; color: #2c3e50; display: block; margin-bottom: 8px; font-size: 13px;">Email Body:</label><div class="email-body" style="max-height: 200px;">${emailBody}</div></div>`;} 
async function approveSubmission(recordId, isAttachment, filename) {
    console.log('=== APPROVE DEBUG ===');
    console.log('Record ID:', recordId);
    console.log('Is Attachment:', isAttachment);
    console.log('Filename:', filename);
    console.log('===================');
    // Get edited text if it's an email body (not attachment)
    let editedBodyText = null;
    if (!isAttachment) {
        const textArea = document.getElementById('emailBodyText');
        if (textArea) {
            editedBodyText = textArea.value;
            console.log('Edited body text length:', editedBodyText.length);
        }
    }
    if (!confirm('Are you sure you want to approve and upload this to the Knowledge Base?')) {
        return;
    }

    try {
        showLoading(true);

        if (isAttachment) {
            console.log('Uploading attachment to Voiceflow via webhook...');
            
            // Upload attachment file to Voiceflow
            const response = await fetch('https://hook.us2.make.com/ku8z97wsy6yrti8iwjapb8d17ef99kfe', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    recordId: recordId,
                    filename: filename
                })
            });

            console.log('Webhook response status:', response.status);
            const responseText = await response.text();
            console.log('Webhook response:', responseText);

            if (!response.ok) {
                throw new Error('Failed to upload attachment to Voiceflow: ' + responseText);
            }
} else {
    console.log('Uploading email body text to Voiceflow...');
    
    // First, update QuickBase with edited text
    console.log('Updating QuickBase with edited text...');
    await makeQuickBaseRequest('POST', 'records', {
        to: QUICKBASE_CONFIG.pendingTableId,
        data: [{
            3: {value: recordId},
            9: {value: btoa(editedBodyText)}  // Update field 9 with edited text (base64 encoded)
        }]
    });
    
    console.log('QuickBase updated. Now calling webhook to upload to Voiceflow...');
    
    // Then call webhook to upload to Voiceflow
    const webhookResponse = await fetch(MAKECOM_WEBHOOK, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            submissionId: recordId,
            action: 'approve',
            reviewerKerberos: currentUser,
            reviewNotes: ''
        })
    });
    
    console.log('Webhook response status:', webhookResponse.status);
    
    if (!webhookResponse.ok) {
        throw new Error('Failed to upload email body via webhook');
    }
}

        // Update QuickBase status to Approved
        console.log('Updating QuickBase status to Approved...');
        await makeQuickBaseRequest('POST', 'records', {
            to: QUICKBASE_CONFIG.pendingTableId,
            data: [{
                3: {value: recordId},
                11: {value: 'Approved'}
            }]
        });

        showMessage('Submission approved and uploaded successfully!', 'success');
        closeModal();
        loadSubmissions();
    } catch (error) {
        console.error('Approval error:', error);
        showMessage('Error approving submission: ' + error.message, 'error');
    } finally {
        showLoading(false);
    }
}
        async function rejectSubmission(recordId) {
    const notes = prompt('Enter rejection reason (optional):');
    
    if (notes === null) {
        return;
    }
    
    try {
        showLoading(true);
        
        // Get the current submission to check if it's an attachment
        const response = await makeQuickBaseRequest('POST', 'records/query', {
            from: QUICKBASE_CONFIG.pendingTableId,
            select: [3, 18],
            where: `{3.EX.${recordId}}`
        });
        
        const submission = response.data[0];
        const filename = submission[18]?.value || '';
        const isAttachment = filename !== '';

        if (isAttachment) {
            // Call rejection webhook to move file to rejected folder
            console.log('Rejecting attachment, moving file to rejected folder...');
            const webhookResponse = await fetch(REJECT_ATTACHMENT_WEBHOOK, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    recordId: recordId,
                    filename: filename
                })
            });
            
            console.log('Rejection webhook response:', webhookResponse.status);
            
            if (!webhookResponse.ok) {
                throw new Error('Failed to move rejected attachment');
            }
            
            console.log('File moved, now updating QuickBase status...');
        }

        // Update QuickBase status to Rejected (for both attachments and email bodies)
        await makeQuickBaseRequest('POST', 'records', {
            to: QUICKBASE_CONFIG.pendingTableId,
            data: [{
                3: {value: recordId},
                11: {value: 'Rejected'},
                14: {value: notes || 'No reason provided'}
            }]
        });

        showMessage('Submission rejected successfully!', 'success');
        closeModal();
        loadSubmissions();
    } catch (error) {
        console.error('Rejection error:', error);
        showMessage('Error rejecting submission: ' + error.message, 'error');
    } finally {
        showLoading(false);
    }
}
        function showRejectForm() {document.getElementById('rejectForm').style.display = 'block';}
        function hideRejectForm() {document.getElementById('rejectForm').style.display = 'none'; document.getElementById('rejectNotes').value = '';}
        async function confirmReject() {const notes = document.getElementById('rejectNotes').value.trim(); showLoading(true); try {const response = await fetch(MAKECOM_WEBHOOK, {method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({submissionId: currentSubmission[3].value, action: 'reject', reviewerKerberos: currentUser, reviewNotes: notes})}); if (!response.ok) {throw new Error('Rejection webhook failed: ' + response.status);} console.log('Rejection webhook called successfully'); showMessage('Submission rejected. Sender has been notified.', 'success'); closeModal(); setTimeout(() => loadSubmissions(), 1000);} catch (error) {console.error('Reject error:', error); showMessage('Error rejecting submission: ' + error.message, 'error');} finally {showLoading(false);}}
        function toggleSelectAll() {const selectAll = document.getElementById('selectAll'); const checkboxes = document.querySelectorAll('.submission-checkbox:not([disabled])'); checkboxes.forEach(cb => cb.checked = selectAll.checked); updateBulkActions();}
        function updateBulkActions() {const checkboxes = document.querySelectorAll('.submission-checkbox:checked'); const count = checkboxes.length; const bulkBar = document.getElementById('bulkActionsBar'); const selectAll = document.getElementById('selectAll'); document.getElementById('selectedCount').textContent = count; if (count > 0) {bulkBar.classList.add('active');} else {bulkBar.classList.remove('active'); selectAll.checked = false;}}
        function clearSelection() {const checkboxes = document.querySelectorAll('.submission-checkbox'); checkboxes.forEach(cb => cb.checked = false); document.getElementById('selectAll').checked = false; updateBulkActions();}
        function getSelectedRecordIds() {const checkboxes = document.querySelectorAll('.submission-checkbox:checked'); return Array.from(checkboxes).map(cb => cb.getAttribute('data-record-id'));}
        async function bulkApprove() {const recordIds = getSelectedRecordIds(); if (recordIds.length === 0) {showMessage('No submissions selected', 'error'); return;} if (!confirm(`Are you sure you want to approve ${recordIds.length} submission(s)?`)) {return;} showLoading(true); let successCount = 0; let errorCount = 0; for (const recordId of recordIds) {try {const response = await fetch(MAKECOM_WEBHOOK, {method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({submissionId: recordId, action: 'approve', reviewerKerberos: currentUser, reviewNotes: 'Bulk approved'})}); if (response.ok) {successCount++;} else {errorCount++;} await new Promise(resolve => setTimeout(resolve, 500));} catch (error) {console.error(`Error approving ${recordId}:`, error); errorCount++;}} showLoading(false); showMessage(`Approved: ${successCount}, Failed: ${errorCount}`, successCount > 0 ? 'success' : 'error'); clearSelection(); setTimeout(() => loadSubmissions(), 1000);}
        async function bulkReject() {const recordIds = getSelectedRecordIds(); if (recordIds.length === 0) {showMessage('No submissions selected', 'error'); return;} const notes = prompt(`Enter rejection notes for ${recordIds.length} submission(s) (optional):`); if (notes === null) return; if (!confirm(`Are you sure you want to reject ${recordIds.length} submission(s)?`)) {return;} showLoading(true); let successCount = 0; let errorCount = 0; for (const recordId of recordIds) {try {const response = await fetch(MAKECOM_WEBHOOK, {method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({submissionId: recordId, action: 'reject', reviewerKerberos: currentUser, reviewNotes: notes || 'Bulk rejected'})}); if (response.ok) {successCount++;} else {errorCount++;} await new Promise(resolve => setTimeout(resolve, 500));} catch (error) {console.error(`Error rejecting ${recordId}:`, error); errorCount++;}} showLoading(false); showMessage(`Rejected: ${successCount}, Failed: ${errorCount}`, successCount > 0 ? 'success' : 'error'); clearSelection(); setTimeout(() => loadSubmissions(), 1000);}
       function closeModal() {
            const reviewModal = document.getElementById('reviewModal');
            const detailModal = document.getElementById('detailModal');
            
            if (reviewModal) reviewModal.style.display = 'none';
            if (detailModal) detailModal.style.display = 'none';
            
            hideRejectForm();
            currentSubmission = null;
        }
        function showMessage(message, type) {const statusMessage = document.getElementById('statusMessage'); statusMessage.textContent = message; statusMessage.className = `status-message status-${type}`; statusMessage.style.display = 'block'; setTimeout(() => {statusMessage.style.display = 'none';}, 5000);}
        function showLoading(show) {document.getElementById('loading').style.display = show ? 'block' : 'none';}
        window.onclick = function(event) {const modal = document.getElementById('reviewModal'); if (event.target == modal) {closeModal();}}

    </script>
<div id="detailModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeModal()">&times;</span>
        <h2>Review Submission</h2>
        <div id="submissionDetails"></div>
    </div>
</div>
</body>
</html>
