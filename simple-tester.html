<!DOCTYPE html>
<html>
<head>
    <title>Voiceflow Chatbot Tester v5 - Enhanced API</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0;
            padding: 20px; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 350px 1fr 400px;
            gap: 20px;
            height: 90vh;
        }
        .panel { 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        .chatbot-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        button { 
            background: #007bff; 
            color: white; 
            border: none; 
            padding: 12px 20px; 
            border-radius: 4px; 
            cursor: pointer; 
            margin: 8px 0;
            width: 100%;
            font-size: 14px;
            font-weight: bold;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.green { background: #28a745; }
        button.green:hover { background: #218838; }
        button.gray { background: #6c757d; }
        button.gray:hover { background: #5a6268; }
        button.red { background: #dc3545; }
        button.red:hover { background: #c82333; }
        button.orange { background: #fd7e14; }
        button.orange:hover { background: #e8690a; }
        .status { 
            padding: 12px; 
            border-radius: 4px; 
            margin: 15px 0;
            font-weight: bold;
            text-align: center;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .section {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            background: #f8f9fa;
        }
        .section h4 {
            margin: 0 0 15px 0;
            color: #495057;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            margin: 8px 0;
            box-sizing: border-box;
            font-family: inherit;
        }
        textarea {
            resize: vertical;
            font-family: monospace;
            font-size: 13px;
        }
        label {
            display: block;
            margin: 8px 0 4px 0;
            font-weight: bold;
            font-size: 13px;
        }
        .questions-display {
            background: #e9ecef;
            border: 1px solid #adb5bd;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }
        .question-item {
            padding: 6px;
            margin: 3px 0;
            border-radius: 3px;
            background: white;
        }
        .question-item.current {
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            font-weight: bold;
        }
        .question-item.completed {
            background: #d4edda;
            border-left: 3px solid #28a745;
        }
        .question-item.error {
            background: #f8d7da;
            border-left: 3px solid #dc3545;
        }
        .transcript {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-size: 13px;
            margin: 15px 0;
        }
        .qa-pair {
            margin: 15px 0;
            padding: 12px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .qa-question {
            background: #007bff;
            color: white;
            padding: 10px;
            border-radius: 6px 6px 0 0;
            font-weight: bold;
        }
        .qa-answer {
            background: #e9ecef;
            color: #333;
            padding: 12px;
            border-radius: 0 0 6px 6px;
            margin-top: 2px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .qa-answer.error {
            background: #f8d7da;
            color: #721c24;
        }
        .qa-waiting {
            background: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 0 0 6px 6px;
            margin-top: 2px;
            font-style: italic;
        }
        .qa-metadata {
            font-size: 11px;
            color: #6c757d;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #dee2e6;
        }
        .message.system {
            background: #d1ecf1;
            color: #0c5460;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            text-align: center;
            font-style: italic;
        }
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        .stat-box {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            text-align: center;
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            font-size: 11px;
            color: #6c757d;
            margin-top: 5px;
        }
        .debug-toggle {
            margin: 10px 0;
        }
        .debug-panel {
            display: none;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
        }
        .debug-panel.active {
            display: block;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: normal;
            cursor: pointer;
        }
        .checkbox-label input {
            width: auto;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Controls -->
        <div class="panel">
            <h2>ü§ñ Chatbot Tester v5</h2>
            <div style="background: #e7f3ff; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 12px;">
                ‚ú® v5: Session reset + Better parsing + Adaptive delays
            </div>
            
            <div class="section">
                <h4>üìù Load Questions</h4>
                
                <label>Manual Questions:</label>
                <textarea id="questionTextArea" rows="8">who is the department head
who is the DAF
how can i create a budget?
how do i request a waiver
how do i request a proposal waiver
how do i request a waiver of search?
does the department still do waivers of search
where is Gabby Hoyte's office
who does Gabby Hoyte support?
who is the development officer?
who supports sertac karaman?</textarea>
                <button onclick="loadFromTextArea()" class="green">üìù Load These Questions</button>
                
                <label>Google Sheet ID (optional):</label>
                <input type="text" id="googleSheetId" placeholder="Enter Google Sheet ID" value="1flnWLAXZGoTpDjkRMuuD3LvyphYIij0gruCu_4x__gQ">
                <button onclick="tryGoogleSheets()" id="googleBtn">üì• Load from Google Sheets</button>
                <div style="font-size: 11px; color: #6c757d; margin: 5px 0;" id="googleStatus">Optional: Load from Google Sheets</div>
            </div>

            <div class="section">
                <h4>‚öôÔ∏è API Configuration</h4>
                <label>Voiceflow API Key:</label>
                <input type="text" id="apiKey" placeholder="VF.DM.66df267d16a9116a91c9f126fab7e.pZsTqAbO2vhQgVNa" style="font-family: monospace; font-size: 11px;">
                <div style="font-size: 11px; color: #6c757d; margin: 5px 0;">Get from Voiceflow ‚Üí Integrations page</div>
                <label>User ID:</label>
                <input type="text" id="userId" value="mit-tester" placeholder="Enter user ID">
                <label>Version ID:</label>
                <select id="versionId">
                    <option value="production">production</option>
                    <option value="development">development</option>
                </select>
                <label>Delay between questions (ms):</label>
                <input type="number" id="delayMs" value="1500" min="500" max="10000" step="100">
                <label class="checkbox-label">
                    <input type="checkbox" id="resetSession" checked>
                    Reset session before test (recommended)
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="debugMode">
                    Debug mode (show raw API responses)
                </label>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-number" id="statQuestions">0</div>
                    <div class="stat-label">Questions Loaded</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="statCompleted">0</div>
                    <div class="stat-label">Completed</div>
                </div>
            </div>

            <div class="status" id="mainStatus">Ready - load questions above</div>

            <button onclick="loadChatbot()" id="loadChatBtn">üîó Load Chatbot (Visual Only)</button>
            <button onclick="startTest()" id="startBtn" disabled>‚ñ∂Ô∏è Start Automated Test</button>
            <button onclick="stopTest()" id="stopBtn" disabled class="red">‚èπÔ∏è Stop Test</button>

            <div class="questions-display" id="questionsDisplay">
                <div style="text-align: center; color: #6c757d;">Load questions above to see them here</div>
            </div>
        </div>

        <!-- Middle Panel: Chatbot (Visual Reference Only) -->
        <div class="chatbot-panel">
            <iframe id="chatIframe" src="about:blank"></iframe>
        </div>

        <!-- Right Panel: Transcript -->
        <div class="panel">
            <h3>üí¨ Live Q&A Transcript</h3>
            <div class="transcript" id="transcript">
                <div class="message system">Q&A pairs will appear here during testing</div>
            </div>
            <button onclick="clearTranscript()">üóëÔ∏è Clear Transcript</button>
            <button onclick="copyToClipboard()" class="green">üìã Copy Transcript</button>
            <button onclick="exportToCSV()" class="gray">üìä Export CSV</button>
            <button onclick="toggleDebug()" class="orange" id="debugToggleBtn">üîç Show Debug Log</button>
            <div class="debug-panel" id="debugPanel"></div>
        </div>
    </div>

    <script>
        let questionsList = [];
        let currentQuestionIndex = 0;
        let testRunning = false;
        let qaResults = [];
        let debugLog = [];

        // Voiceflow API configuration
        const VOICEFLOW_API_URL = 'https://general-runtime.voiceflow.com';

        function addDebugLog(message, data = null) {
            const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
            const logEntry = {
                time: timestamp,
                message: message,
                data: data
            };
            debugLog.push(logEntry);
            
            if (document.getElementById('debugMode').checked) {
                console.log(`[${timestamp}] ${message}`, data || '');
                updateDebugPanel();
            }
        }

        function updateDebugPanel() {
            const panel = document.getElementById('debugPanel');
            panel.innerHTML = debugLog.slice(-50).map(entry => {
                let html = `<div style="margin: 5px 0; padding: 5px; background: white; border-radius: 3px;">`;
                html += `<strong>[${entry.time}]</strong> ${entry.message}`;
                if (entry.data) {
                    html += `<pre style="margin: 5px 0; font-size: 10px;">${JSON.stringify(entry.data, null, 2)}</pre>`;
                }
                html += `</div>`;
                return html;
            }).join('');
            panel.scrollTop = panel.scrollHeight;
        }

        function toggleDebug() {
            const panel = document.getElementById('debugPanel');
            const btn = document.getElementById('debugToggleBtn');
            panel.classList.toggle('active');
            btn.textContent = panel.classList.contains('active') ? 'üîç Hide Debug Log' : 'üîç Show Debug Log';
            if (panel.classList.contains('active')) {
                updateDebugPanel();
            }
        }

        function updateStats() {
            document.getElementById('statQuestions').textContent = questionsList.length;
            const completed = qaResults.filter(qa => qa.answer !== 'WAITING').length;
            document.getElementById('statCompleted').textContent = completed;
        }

        function updateStatus(message, type = 'info') {
            const status = document.getElementById('mainStatus');
            status.textContent = message;
            status.className = `status ${type}`;
        }

        function addSystemMessage(message) {
            const transcript = document.getElementById('transcript');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.textContent = message;
            transcript.appendChild(messageDiv);
            transcript.scrollTop = transcript.scrollHeight;
        }

        function loadFromTextArea() {
            const textarea = document.getElementById('questionTextArea');
            const text = textarea.value;
            const questions = text.split('\n')
                .map(q => q.trim())
                .filter(q => q.length > 0);
            
            if (questions.length === 0) {
                updateStatus('No questions found in text area', 'error');
                return;
            }

            questionsList = questions;
            updateStatus(`Loaded ${questionsList.length} questions`, 'success');
            addSystemMessage(`‚úÖ Loaded ${questionsList.length} questions from text area`);
            addDebugLog(`Loaded ${questionsList.length} questions from textarea`);
            displayQuestions();
            updateStats();
            checkReadyToTest();
        }

        function displayQuestions() {
            const display = document.getElementById('questionsDisplay');
            display.innerHTML = '';
            
            questionsList.forEach((q, index) => {
                const div = document.createElement('div');
                div.className = 'question-item';
                div.id = `question-${index}`;
                div.textContent = `${index + 1}. ${q}`;
                display.appendChild(div);
            });
        }

        async function tryGoogleSheets() {
            const btn = document.getElementById('googleBtn');
            const status = document.getElementById('googleStatus');
            const sheetId = document.getElementById('googleSheetId').value.trim();

            if (!sheetId) {
                updateStatus('Please enter a Google Sheet ID', 'error');
                return;
            }

            btn.disabled = true;
            btn.textContent = '‚è≥ Loading...';
            status.textContent = 'Attempting to fetch...';
            addDebugLog('Attempting to load from Google Sheets', { sheetId });

            try {
                const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
                
                const controller = new AbortController();
                setTimeout(() => controller.abort(), 8000);
                
                const response = await fetch(url, {
                    signal: controller.signal,
                    mode: 'cors'
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status} - Sheet may not be published`);
                }

                const csvText = await response.text();
                const lines = csvText.split('\n');
                const questions = lines
                    .slice(1)
                    .map(line => line.split(',')[0])
                    .filter(q => q && q.trim())
                    .map(q => q.replace(/"/g, '').trim());

                if (questions.length === 0) {
                    throw new Error('No questions found in first column');
                }

                questionsList = questions;
                updateStatus(`Loaded ${questionsList.length} questions from Google Sheets`, 'success');
                addSystemMessage(`‚úÖ Loaded ${questionsList.length} questions from Google Sheets`);
                addDebugLog(`Successfully loaded ${questionsList.length} questions from Google Sheets`);
                status.textContent = `Success: ${questionsList.length} questions loaded`;
                displayQuestions();
                updateStats();
                checkReadyToTest();

            } catch (error) {
                let errorMsg = error.message;
                if (error.name === 'AbortError') {
                    errorMsg = 'Timed out - sheet may not be published';
                }
                
                updateStatus(`Google Sheets failed: ${errorMsg}`, 'error');
                status.textContent = `Failed: ${errorMsg}`;
                addDebugLog('Google Sheets load failed', { error: errorMsg });
            } finally {
                btn.textContent = 'üì• Load from Google Sheets';
                btn.disabled = false;
            }
        }

        function loadChatbot() {
            const iframe = document.getElementById('chatIframe');
            iframe.src = 'https://aeroastrovfbot.netlify.app/chatbot.html';
            
            updateStatus('Chatbot loaded (for visual reference)', 'info');
            addSystemMessage('üîó Chatbot loaded (visual only - test uses API directly)');
            addDebugLog('Chatbot iframe loaded');
            checkReadyToTest();
        }

        function checkReadyToTest() {
            const startBtn = document.getElementById('startBtn');
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (questionsList.length > 0 && apiKey) {
                startBtn.disabled = false;
                updateStatus('Ready to start testing!', 'success');
            } else if (questionsList.length > 0 && !apiKey) {
                startBtn.disabled = true;
                updateStatus('Enter your Voiceflow API Key to continue', 'warning');
            }
        }

        async function resetSession() {
            const userId = document.getElementById('userId').value || 'mit-tester';
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (!apiKey) {
                addDebugLog('Cannot reset session - API key not provided');
                return false;
            }
            
            addDebugLog('Attempting to reset session', { userId });
            
            try {
                const response = await fetch(`${VOICEFLOW_API_URL}/state/user/${userId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': apiKey
                    }
                });
                
                if (response.ok) {
                    addDebugLog('Session reset successfully');
                    addSystemMessage('üîÑ Session reset - starting fresh conversation');
                    return true;
                } else {
                    addDebugLog('Session reset returned non-OK status', { status: response.status });
                    return false;
                }
            } catch (error) {
                addDebugLog('Session reset failed', { error: error.message });
                console.error('Failed to reset session:', error);
                return false;
            }
        }

        async function startTest() {
            if (questionsList.length === 0) {
                updateStatus('Please load questions first', 'error');
                return;
            }

            currentQuestionIndex = 0;
            qaResults = [];
            debugLog = [];
            testRunning = true;
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('loadChatBtn').disabled = true;
            
            addDebugLog('Starting test', { questionCount: questionsList.length });
            
            // Reset session if checkbox is checked
            if (document.getElementById('resetSession').checked) {
                updateStatus('Resetting session...', 'warning');
                await resetSession();
                // Small delay after reset
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            updateStatus('Testing in progress...', 'warning');
            addSystemMessage(`üöÄ Starting API-based test with ${questionsList.length} questions`);
            updateStats();
            
            await sendNextQuestion();
        }

        function parseVoiceflowResponse(data) {
            let responseText = '';
            let hasResponse = false;
            const metadata = {
                traceTypes: [],
                hasText: false,
                hasSpeak: false,
                hasVisual: false,
                hasCard: false,
                hasButtons: false
            };

            if (!Array.isArray(data)) {
                addDebugLog('Response is not an array', { data });
                return { text: 'Invalid response format', metadata };
            }

            for (const trace of data) {
                metadata.traceTypes.push(trace.type);
                
                if (trace.type === 'text' && trace.payload?.message) {
                    responseText += trace.payload.message + '\n\n';
                    hasResponse = true;
                    metadata.hasText = true;
                } 
                else if (trace.type === 'speak' && trace.payload?.message) {
                    responseText += trace.payload.message + '\n\n';
                    hasResponse = true;
                    metadata.hasSpeak = true;
                } 
                else if (trace.type === 'visual') {
                    metadata.hasVisual = true;
                    if (trace.payload?.visualType === 'text' && trace.payload?.text) {
                        responseText += trace.payload.text + '\n\n';
                        hasResponse = true;
                    } else if (trace.payload?.image) {
                        responseText += '[Image]\n';
                        hasResponse = true;
                    }
                } 
                else if (trace.type === 'card' && trace.payload) {
                    metadata.hasCard = true;
                    responseText += `[Card: ${trace.payload.title || 'Untitled'}]\n`;
                    if (trace.payload.description) {
                        responseText += trace.payload.description + '\n';
                    }
                    if (trace.payload.text) {
                        responseText += trace.payload.text + '\n';
                    }
                    responseText += '\n';
                    hasResponse = true;
                }
                else if (trace.type === 'choice' || trace.type === 'buttons') {
                    metadata.hasButtons = true;
                    if (trace.payload?.buttons && Array.isArray(trace.payload.buttons)) {
                        responseText += '[Buttons: ';
                        responseText += trace.payload.buttons.map(b => b.name || b.label).join(', ');
                        responseText += ']\n\n';
                        hasResponse = true;
                    }
                }
            }

            responseText = responseText.trim();
            
            if (!responseText) {
                if (hasResponse) {
                    responseText = '[Response contains non-text elements]';
                } else if (metadata.traceTypes.length > 0) {
                    responseText = `[No text content - trace types: ${metadata.traceTypes.join(', ')}]`;
                } else {
                    responseText = 'No response received';
                }
            }

            return { text: responseText, metadata };
        }

        async function sendNextQuestion() {
            if (!testRunning || currentQuestionIndex >= questionsList.length) {
                if (currentQuestionIndex >= questionsList.length) {
                    stopTest();
                    updateStatus('All questions completed!', 'success');
                    addSystemMessage('üéâ All questions completed!');
                    addDebugLog('Test completed successfully');
                }
                return;
            }

            const question = questionsList[currentQuestionIndex];
            const questionNum = currentQuestionIndex + 1;
            
            // Update question display
            document.querySelectorAll('.question-item').forEach(item => {
                item.classList.remove('current');
            });
            const currentItem = document.getElementById(`question-${currentQuestionIndex}`);
            if (currentItem) {
                currentItem.classList.add('current');
            }

            // Add to results as waiting
            qaResults.push({
                question: question,
                answer: 'WAITING',
                timestamp: new Date().toISOString()
            });

            updateTranscriptDisplay();
            
            addDebugLog(`Sending Q${questionNum}`, { question });
            
            try {
                const startTime = Date.now();
                const userId = document.getElementById('userId').value || 'mit-tester';
                const apiKey = document.getElementById('apiKey').value.trim();
                const versionId = document.getElementById('versionId').value;
                
                if (!apiKey) {
                    throw new Error('API Key is required. Get it from Voiceflow ‚Üí Integrations page');
                }
                
                const requestBody = {
                    request: {
                        type: 'text',
                        payload: question
                    }
                };
                
                addDebugLog('API Request', requestBody);
                
                // Send question to Voiceflow API
                const response = await fetch(`${VOICEFLOW_API_URL}/state/user/${userId}/interact`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': apiKey,
                        'versionID': versionId
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    let errorDetail = response.statusText;
                    try {
                        const errorBody = await response.json();
                        errorDetail = errorBody.message || errorBody.error || errorDetail;
                        addDebugLog('API Error Response', errorBody);
                    } catch {}
                    throw new Error(`API ${response.status}: ${errorDetail}`);
                }

                const data = await response.json();
                const responseTime = Date.now() - startTime;
                
                addDebugLog('API Response received', { 
                    responseTime: `${responseTime}ms`,
                    traceCount: Array.isArray(data) ? data.length : 0
                });
                
                if (document.getElementById('debugMode').checked) {
                    addDebugLog('Full API Response', data);
                }
                
                // Parse response
                const parsed = parseVoiceflowResponse(data);
                
                // Update the Q&A pair
                qaResults[qaResults.length - 1] = {
                    question: question,
                    answer: parsed.text,
                    timestamp: new Date().toISOString(),
                    responseTime: responseTime,
                    metadata: parsed.metadata
                };

                updateTranscriptDisplay();
                updateStats();
                
                // Mark as completed
                if (currentItem) {
                    currentItem.classList.remove('current');
                    currentItem.classList.add('completed');
                }
                
                addDebugLog(`Q${questionNum} completed`, { 
                    responseTime: `${responseTime}ms`,
                    answerLength: parsed.text.length 
                });

            } catch (error) {
                console.error('Error:', error);
                addDebugLog(`Q${questionNum} failed`, { error: error.message });
                
                qaResults[qaResults.length - 1].answer = `‚ùå Error: ${error.message}`;
                qaResults[qaResults.length - 1].isError = true;
                
                if (currentItem) {
                    currentItem.classList.remove('current');
                    currentItem.classList.add('error');
                }
                
                updateTranscriptDisplay();
            }

            currentQuestionIndex++;
            
            // Adaptive delay based on previous response time
            let delay = parseInt(document.getElementById('delayMs').value) || 1500;
            
            const lastResult = qaResults[qaResults.length - 1];
            if (lastResult.responseTime && lastResult.responseTime > 3000) {
                delay = Math.max(delay, 2000); // Longer delay for slow responses
                addDebugLog('Using extended delay due to slow response', { delay: `${delay}ms` });
            }
            
            // Continue to next question after delay
            if (testRunning) {
                setTimeout(sendNextQuestion, delay);
            }
        }

        function stopTest() {
            testRunning = false;
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('loadChatBtn').disabled = false;
            
            updateStatus('Test stopped', 'info');
            addSystemMessage('‚èπÔ∏è Test stopped');
            addDebugLog('Test stopped by user');
        }

        function updateTranscriptDisplay() {
            const transcript = document.getElementById('transcript');
            transcript.innerHTML = '';

            qaResults.forEach((qa, index) => {
                const qaDiv = document.createElement('div');
                qaDiv.className = 'qa-pair';
                
                const questionDiv = document.createElement('div');
                questionDiv.className = 'qa-question';
                questionDiv.textContent = `Q${index + 1}: ${qa.question}`;
                
                const answerDiv = document.createElement('div');
                if (qa.answer === 'WAITING') {
                    answerDiv.className = 'qa-waiting';
                    answerDiv.textContent = '‚è≥ Waiting for response...';
                } else {
                    answerDiv.className = qa.isError ? 'qa-answer error' : 'qa-answer';
                    answerDiv.textContent = qa.answer;
                    
                    // Add metadata
                    if (qa.responseTime || qa.metadata) {
                        const metaDiv = document.createElement('div');
                        metaDiv.className = 'qa-metadata';
                        
                        let metaText = '';
                        if (qa.responseTime) {
                            metaText += `‚è±Ô∏è Response time: ${(qa.responseTime / 1000).toFixed(1)}s`;
                        }
                        if (qa.metadata && qa.metadata.traceTypes.length > 0) {
                            if (metaText) metaText += ' ‚Ä¢ ';
                            metaText += `Trace types: ${qa.metadata.traceTypes.join(', ')}`;
                        }
                        
                        metaDiv.textContent = metaText;
                        answerDiv.appendChild(metaDiv);
                    }
                }
                
                qaDiv.appendChild(questionDiv);
                qaDiv.appendChild(answerDiv);
                transcript.appendChild(qaDiv);
            });

            transcript.scrollTop = transcript.scrollHeight;
        }

        function clearTranscript() {
            if (testRunning) {
                if (!confirm('Test is running. Are you sure you want to clear?')) {
                    return;
                }
            }
            
            qaResults = [];
            debugLog = [];
            updateTranscriptDisplay();
            updateDebugPanel();
            addSystemMessage('Transcript cleared');
            updateStats();
        }

        function copyToClipboard() {
            let text = '=== VOICEFLOW TEST RESULTS ===\n\n';
            text += `Test Date: ${new Date().toLocaleString()}\n`;
            text += `Total Questions: ${qaResults.length}\n`;
            text += `Completed: ${qaResults.filter(qa => qa.answer !== 'WAITING' && !qa.isError).length}\n`;
            text += `Errors: ${qaResults.filter(qa => qa.isError).length}\n\n`;
            text += '---\n\n';
            
            qaResults.forEach((qa, index) => {
                text += `Q${index + 1}: ${qa.question}\n`;
                text += `A${index + 1}: ${qa.answer}\n`;
                if (qa.responseTime) {
                    text += `Time: ${(qa.responseTime / 1000).toFixed(1)}s\n`;
                }
                text += '\n---\n\n';
            });
            
            navigator.clipboard.writeText(text).then(() => {
                addSystemMessage('üìã Transcript copied to clipboard');
            });
        }

        function exportToCSV() {
            let csv = 'Question Number,Question,Answer,Response Time (seconds),Status\n';
            
            qaResults.forEach((qa, index) => {
                const question = qa.question.replace(/"/g, '""');
                const answer = qa.answer.replace(/"/g, '""').replace(/\n/g, ' ');
                const time = qa.responseTime ? (qa.responseTime / 1000).toFixed(1) : 'N/A';
                const status = qa.isError ? 'Error' : (qa.answer === 'WAITING' ? 'Pending' : 'Success');
                csv += `${index + 1},"${question}","${answer}",${time},${status}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `voiceflow-test-${new Date().toISOString().slice(0,10)}.csv`;
            a.click();
            
            addSystemMessage('üìä CSV exported successfully');
        }

        // Initialize
        window.addEventListener('load', () => {
            addSystemMessage('ü§ñ Chatbot Tester v5 Ready');
            addSystemMessage('‚ú® New: Session reset, better parsing, adaptive delays');
            addSystemMessage('Step 1: Enter your Voiceflow API Key (from Integrations page)');
            addSystemMessage('Step 2: Load questions');
            addSystemMessage('Step 3: Start testing');
            
            // Add event listener to API key field
            document.getElementById('apiKey').addEventListener('input', checkReadyToTest);
        });
    </script>
</body>
</html>
