<!DOCTYPE html>
<html>
<head>
    <title>Voiceflow Chatbot Tester v5.4 - Testing Basic Agent</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0;
            padding: 20px; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 350px 1fr 400px;
            gap: 20px;
            height: 90vh;
        }
        .panel { 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        .chatbot-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        button { 
            background: #007bff; 
            color: white; 
            border: none; 
            padding: 12px 20px; 
            border-radius: 4px; 
            cursor: pointer; 
            margin: 8px 0;
            width: 100%;
            font-size: 14px;
            font-weight: bold;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.green { background: #28a745; }
        button.green:hover { background: #218838; }
        button.red { background: #dc3545; }
        button.red:hover { background: #c82333; }
        .status { 
            padding: 12px; 
            border-radius: 4px; 
            margin: 15px 0;
            font-weight: bold;
            text-align: center;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.warning { background: #fff3cd; color: #856404; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .section {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            background: #f8f9fa;
        }
        .section h4 {
            margin: 0 0 15px 0;
            color: #495057;
        }
        input, textarea, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            margin: 8px 0;
            box-sizing: border-box;
            font-family: inherit;
        }
        textarea {
            resize: vertical;
            font-family: monospace;
            font-size: 13px;
        }
        label {
            display: block;
            margin: 8px 0 4px 0;
            font-weight: bold;
            font-size: 13px;
        }
        .questions-display {
            background: #e9ecef;
            border: 1px solid #adb5bd;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }
        .question-item {
            padding: 6px;
            margin: 3px 0;
            border-radius: 3px;
            background: white;
        }
        .question-item.current {
            background: #fff3cd;
            border-left: 3px solid #ffc107;
            font-weight: bold;
        }
        .question-item.completed {
            background: #d4edda;
            border-left: 3px solid #28a745;
        }
        .question-item.error {
            background: #f8d7da;
            border-left: 3px solid #dc3545;
        }
        .transcript {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-size: 13px;
            margin: 15px 0;
        }
        .qa-pair {
            margin: 15px 0;
            padding: 12px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .qa-question {
            background: #007bff;
            color: white;
            padding: 10px;
            border-radius: 6px 6px 0 0;
            font-weight: bold;
        }
        .qa-answer {
            background: #e9ecef;
            color: #333;
            padding: 12px;
            border-radius: 0 0 6px 6px;
            margin-top: 2px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .qa-answer.error {
            background: #f8d7da;
            color: #721c24;
        }
        .qa-waiting {
            background: #fff3cd;
            color: #856404;
            padding: 10px;
            border-radius: 0 0 6px 6px;
            margin-top: 2px;
            font-style: italic;
        }
        .qa-metadata {
            font-size: 11px;
            color: #6c757d;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #dee2e6;
        }
        .message.system {
            background: #d1ecf1;
            color: #0c5460;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            text-align: center;
            font-style: italic;
        }
        iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        .stat-box {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            text-align: center;
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            font-size: 11px;
            color: #6c757d;
            margin-top: 5px;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: normal;
            cursor: pointer;
        }
        .checkbox-label input {
            width: auto;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Panel: Controls -->
        <div class="panel">
            <h2>ü§ñ Chatbot Tester v5.4</h2>
            <div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 12px;">
                üêõ DEBUG EDITION: Check browser console (F12) for detailed logs
            </div>
            
            <div class="section">
                <h4>üìù Load Questions</h4>
                
                <label>Manual Questions:</label>
                <textarea id="questionTextArea" rows="8">who is the department head
who is the DAF
how can i create a budget?
how do i request a waiver
how do i request a proposal waiver</textarea>
                <button onclick="loadFromTextArea()" class="green">üìù Load These Questions</button>
            </div>

            <div class="section">
                <h4>‚öôÔ∏è API Configuration</h4>
                <label>Voiceflow API Key:</label>
                <input type="text" id="apiKey" value="VF.DM.690232ebc72a4f5485d01113.Z1eYyYt0nEAFow59" style="font-family: monospace; font-size: 11px;">
                <div style="font-size: 11px; color: #6c757d; margin: 5px 0;">Testing with BASIC agent</div>
                
                <label>Project ID:</label>
                <input type="text" id="projectId" value="66de313d6a0d94e1bd71c5ce" style="font-family: monospace; font-size: 11px;">
                <div style="font-size: 11px; color: #6c757d; margin: 5px 0;">Get from Voiceflow ‚Üí Agent Settings</div>
                
                <label>User ID:</label>
                <input type="text" id="userId" value="mit-tester-debug" placeholder="Enter user ID">
                
                <label>Version ID:</label>
                <select id="versionId">
                    <option value="development" selected>development</option>
                    <option value="production">production</option>
                </select>
                
                <label>Delay between questions (ms):</label>
                <input type="number" id="delayMs" value="2000" min="500" max="10000" step="100">
                
                <label class="checkbox-label">
                    <input type="checkbox" id="resetSession" checked>
                    Reset session before test
                </label>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-number" id="statQuestions">0</div>
                    <div class="stat-label">Questions Loaded</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="statCompleted">0</div>
                    <div class="stat-label">Completed</div>
                </div>
            </div>

            <div class="status" id="mainStatus">Ready</div>

            <button onclick="testConnection()" id="testBtn">üîå Test API Connection</button>
            <button onclick="startTest()" id="startBtn" disabled>‚ñ∂Ô∏è Start Automated Test</button>
            <button onclick="stopTest()" id="stopBtn" disabled class="red">‚èπÔ∏è Stop Test</button>

            <div class="questions-display" id="questionsDisplay">
                <div style="text-align: center; color: #6c757d;">Load questions above</div>
            </div>
        </div>

        <!-- Middle Panel: Chatbot -->
        <div class="chatbot-panel">
            <iframe id="chatIframe" src="about:blank"></iframe>
        </div>

        <!-- Right Panel: Transcript -->
        <div class="panel">
            <h3>üí¨ Live Q&A Transcript</h3>
            <div class="transcript" id="transcript">
                <div class="message system">Q&A pairs will appear here</div>
            </div>
            <button onclick="clearTranscript()">üóëÔ∏è Clear Transcript</button>
            <button onclick="copyToClipboard()" class="green">üìã Copy Transcript</button>
        </div>
    </div>

    <script>
        console.log('üöÄ Script loaded - v5.4 Testing Basic Agent');
        
        let questionsList = [];
        let currentQuestionIndex = 0;
        let testRunning = false;
        let qaResults = [];
        let workingEndpointFormat = 0; // 0 or 1, stores which endpoint format works

        const VOICEFLOW_API_URL = 'https://general-runtime.voiceflow.com';

        function log(message, data = null) {
            const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
            if (data) {
                console.log(`[${timestamp}] ${message}`, data);
            } else {
                console.log(`[${timestamp}] ${message}`);
            }
        }

        function updateStats() {
            const completed = qaResults.filter(qa => qa.answer !== 'WAITING').length;
            document.getElementById('statQuestions').textContent = questionsList.length;
            document.getElementById('statCompleted').textContent = completed;
            log(`Stats updated: ${questionsList.length} questions, ${completed} completed`);
        }

        function updateStatus(message, type = 'info') {
            const status = document.getElementById('mainStatus');
            status.textContent = message;
            status.className = `status ${type}`;
            log(`Status: ${message} (${type})`);
        }

        function addSystemMessage(message) {
            const transcript = document.getElementById('transcript');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.textContent = message;
            transcript.appendChild(messageDiv);
            transcript.scrollTop = transcript.scrollHeight;
            log(`System message: ${message}`);
        }

        function loadFromTextArea() {
            log('Loading questions from textarea');
            const textarea = document.getElementById('questionTextArea');
            const text = textarea.value;
            const questions = text.split('\n')
                .map(q => q.trim())
                .filter(q => q.length > 0);
            
            log('Parsed questions:', questions);
            
            if (questions.length === 0) {
                updateStatus('No questions found', 'error');
                return;
            }

            questionsList = questions;
            updateStatus(`Loaded ${questionsList.length} questions`, 'success');
            addSystemMessage(`‚úÖ Loaded ${questionsList.length} questions`);
            displayQuestions();
            updateStats();
            checkReadyToTest();
        }

        function displayQuestions() {
            log('Displaying questions in UI');
            const display = document.getElementById('questionsDisplay');
            display.innerHTML = '';
            
            questionsList.forEach((q, index) => {
                const div = document.createElement('div');
                div.className = 'question-item';
                div.id = `question-${index}`;
                div.textContent = `${index + 1}. ${q}`;
                display.appendChild(div);
            });
        }

        function checkReadyToTest() {
            log('Checking if ready to test');
            const startBtn = document.getElementById('startBtn');
            const testBtn = document.getElementById('testBtn');
            const apiKey = document.getElementById('apiKey').value.trim();
            
            log('Check ready:', { 
                questionsLoaded: questionsList.length,
                hasApiKey: !!apiKey,
                apiKeyLength: apiKey.length
            });
            
            if (apiKey) {
                testBtn.disabled = false;
            }
            
            if (questionsList.length > 0 && apiKey) {
                startBtn.disabled = false;
                updateStatus('Ready to start testing!', 'success');
            } else if (questionsList.length > 0 && !apiKey) {
                startBtn.disabled = true;
                updateStatus('Enter API Key to continue', 'warning');
            } else if (!questionsList.length && apiKey) {
                startBtn.disabled = true;
                updateStatus('Load questions to continue', 'warning');
            }
        }

        async function testConnection() {
            log('Testing API connection');
            const apiKey = document.getElementById('apiKey').value.trim();
            const userId = document.getElementById('userId').value || 'test-user';
            const versionId = document.getElementById('versionId').value;
            const projectId = document.getElementById('projectId').value.trim();
            
            if (!apiKey) {
                updateStatus('Enter API Key first', 'error');
                alert('Please enter your Voiceflow API Key');
                return;
            }
            
            updateStatus('Testing connection...', 'warning');
            addSystemMessage('üîå Testing API connection...');
            
            // Try multiple endpoint formats
            const endpoints = [
                `${VOICEFLOW_API_URL}/state/user/${userId}/interact`,
                `${VOICEFLOW_API_URL}/v2/project/${projectId}/user/${userId}/interact`
            ];
            
            for (let i = 0; i < endpoints.length; i++) {
                const url = endpoints[i];
                try {
                    log(`Attempt ${i + 1}: Testing endpoint`, { url, versionId });
                    
                    const requestBody = {
                        action: {
                            type: 'launch'
                        },
                        config: {
                            excludeTypes: ['flow', 'block']
                        }
                    };
                    
                    log('Request body:', requestBody);
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': apiKey,
                            'versionID': versionId
                        },
                        body: JSON.stringify(requestBody)
                    });
                    
                    log(`Attempt ${i + 1} response:`, {
                        status: response.status,
                        statusText: response.statusText,
                        ok: response.ok
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        log('‚úÖ SUCCESS with endpoint:', url);
                        log('API Response data:', data);
                        
                        workingEndpointFormat = i; // Save which format worked
                        
                        updateStatus(`‚úÖ Connection successful! (Using endpoint ${i + 1})`, 'success');
                        addSystemMessage(`‚úÖ API connection successful! Endpoint: ${url.split('/').slice(3).join('/')}`);
                        alert(`Connection successful!\n\nEndpoint: ${url.split('/').slice(3).join('/')}`);
                        return;
                    }
                    
                    // If not ok, try to get error details but continue to next endpoint
                    const errorText = await response.text();
                    log(`Attempt ${i + 1} failed:`, errorText);
                    
                } catch (error) {
                    log(`Attempt ${i + 1} error:`, error);
                }
            }
            
            // If we got here, all attempts failed
            updateStatus('‚ùå All connection attempts failed', 'error');
            addSystemMessage('‚ùå All connection attempts failed. Check console for details.');
            alert('Connection failed with all endpoint formats.\n\nCheck console (F12) for details.\n\nPossible issues:\n- API key may be invalid\n- Project ID may be incorrect\n- Agent not published to production');
        }

        async function resetSession() {
            const userId = document.getElementById('userId').value || 'mit-tester-debug';
            const apiKey = document.getElementById('apiKey').value.trim();
            
            log('Resetting session', { userId });
            
            if (!apiKey) {
                log('Cannot reset - no API key');
                return false;
            }
            
            try {
                const response = await fetch(`${VOICEFLOW_API_URL}/state/user/${userId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': apiKey
                    }
                });
                
                log('Session reset response:', { status: response.status, ok: response.ok });
                
                if (response.ok) {
                    addSystemMessage('üîÑ Session reset');
                    return true;
                }
                return false;
            } catch (error) {
                log('Session reset error:', error);
                return false;
            }
        }

        async function startTest() {
            log('Starting test');
            
            if (questionsList.length === 0) {
                updateStatus('Load questions first', 'error');
                alert('Please load questions first');
                return;
            }
            
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                updateStatus('Enter API Key first', 'error');
                alert('Please enter your Voiceflow API Key');
                return;
            }

            currentQuestionIndex = 0;
            qaResults = [];
            testRunning = true;
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('testBtn').disabled = true;
            
            log('Test starting', { questionCount: questionsList.length });
            
            // Reset session if checked
            if (document.getElementById('resetSession').checked) {
                updateStatus('Resetting session...', 'warning');
                await resetSession();
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            updateStatus('Testing in progress...', 'warning');
            addSystemMessage(`üöÄ Starting test with ${questionsList.length} questions`);
            updateStats();
            
            await sendNextQuestion();
        }

        function parseVoiceflowResponse(data) {
            log('Parsing Voiceflow response', data);
            
            let responseText = '';
            const metadata = { traceTypes: [] };

            if (!Array.isArray(data)) {
                log('Response is not an array!');
                return { text: 'Invalid response format', metadata };
            }

            for (const trace of data) {
                metadata.traceTypes.push(trace.type);
                
                if (trace.type === 'text' && trace.payload?.message) {
                    responseText += trace.payload.message + '\n\n';
                } 
                else if (trace.type === 'speak' && trace.payload?.message) {
                    responseText += trace.payload.message + '\n\n';
                }
            }

            responseText = responseText.trim() || `[No text - types: ${metadata.traceTypes.join(', ')}]`;
            
            log('Parsed response:', { text: responseText, metadata });
            return { text: responseText, metadata };
        }

        async function sendNextQuestion() {
            if (!testRunning || currentQuestionIndex >= questionsList.length) {
                if (currentQuestionIndex >= questionsList.length) {
                    stopTest();
                    updateStatus('All questions completed!', 'success');
                    addSystemMessage('üéâ Test completed!');
                }
                return;
            }

            const question = questionsList[currentQuestionIndex];
            const questionNum = currentQuestionIndex + 1;
            
            log(`\n=== Sending Q${questionNum} ===`);
            log('Question:', question);
            
            // Update UI
            document.querySelectorAll('.question-item').forEach(item => {
                item.classList.remove('current');
            });
            const currentItem = document.getElementById(`question-${currentQuestionIndex}`);
            if (currentItem) {
                currentItem.classList.add('current');
            }

            // Add to results as waiting
            qaResults.push({
                question: question,
                answer: 'WAITING',
                timestamp: new Date().toISOString()
            });

            updateTranscriptDisplay();
            
            try {
                const startTime = Date.now();
                const userId = document.getElementById('userId').value || 'mit-tester-debug';
                const apiKey = document.getElementById('apiKey').value.trim();
                const versionId = document.getElementById('versionId').value;
                const projectId = document.getElementById('projectId').value.trim();
                
                // Build URL based on which endpoint format worked in the connection test
                const urls = [
                    `${VOICEFLOW_API_URL}/state/user/${userId}/interact`,
                    `${VOICEFLOW_API_URL}/v2/project/${projectId}/user/${userId}/interact`
                ];
                const url = urls[workingEndpointFormat];
                
                const requestBody = {
                    action: {
                        type: 'text',
                        payload: question
                    },
                    config: {
                        excludeTypes: ['flow', 'block']
                    }
                };
                
                log('API Request:', {
                    url: url,
                    method: 'POST',
                    body: requestBody,
                    headers: {
                        'Authorization': apiKey.substring(0, 20) + '...',
                        'versionID': versionId
                    }
                });
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': apiKey,
                        'versionID': versionId
                    },
                    body: JSON.stringify(requestBody)
                });

                const responseTime = Date.now() - startTime;
                log('Response received:', { 
                    status: response.status, 
                    ok: response.ok,
                    responseTime: `${responseTime}ms`
                });

                if (!response.ok) {
                    let errorDetail = response.statusText;
                    try {
                        const errorBody = await response.json();
                        log('Error body:', errorBody);
                        errorDetail = errorBody.message || errorBody.error || errorDetail;
                    } catch {}
                    throw new Error(`API ${response.status}: ${errorDetail}`);
                }

                const data = await response.json();
                log('API Response data:', data);
                
                const parsed = parseVoiceflowResponse(data);
                
                // Update result
                qaResults[qaResults.length - 1] = {
                    question: question,
                    answer: parsed.text,
                    timestamp: new Date().toISOString(),
                    responseTime: responseTime,
                    metadata: parsed.metadata
                };

                updateTranscriptDisplay();
                updateStats();
                
                if (currentItem) {
                    currentItem.classList.remove('current');
                    currentItem.classList.add('completed');
                }
                
                log(`Q${questionNum} completed successfully`);

            } catch (error) {
                log(`Q${questionNum} FAILED:`, error);
                
                qaResults[qaResults.length - 1].answer = `‚ùå Error: ${error.message}`;
                qaResults[qaResults.length - 1].isError = true;
                
                if (currentItem) {
                    currentItem.classList.remove('current');
                    currentItem.classList.add('error');
                }
                
                updateTranscriptDisplay();
            }

            currentQuestionIndex++;
            
            const delay = parseInt(document.getElementById('delayMs').value) || 2000;
            log(`Waiting ${delay}ms before next question`);
            
            if (testRunning) {
                setTimeout(sendNextQuestion, delay);
            }
        }

        function stopTest() {
            log('Stopping test');
            testRunning = false;
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('testBtn').disabled = false;
            
            updateStatus('Test stopped', 'info');
            addSystemMessage('‚èπÔ∏è Test stopped');
        }

        function updateTranscriptDisplay() {
            const transcript = document.getElementById('transcript');
            transcript.innerHTML = '';

            qaResults.forEach((qa, index) => {
                const qaDiv = document.createElement('div');
                qaDiv.className = 'qa-pair';
                
                const questionDiv = document.createElement('div');
                questionDiv.className = 'qa-question';
                questionDiv.textContent = `Q${index + 1}: ${qa.question}`;
                
                const answerDiv = document.createElement('div');
                if (qa.answer === 'WAITING') {
                    answerDiv.className = 'qa-waiting';
                    answerDiv.textContent = '‚è≥ Waiting...';
                } else {
                    answerDiv.className = qa.isError ? 'qa-answer error' : 'qa-answer';
                    answerDiv.textContent = qa.answer;
                    
                    if (qa.responseTime) {
                        const metaDiv = document.createElement('div');
                        metaDiv.className = 'qa-metadata';
                        metaDiv.textContent = `‚è±Ô∏è ${(qa.responseTime / 1000).toFixed(1)}s`;
                        if (qa.metadata?.traceTypes) {
                            metaDiv.textContent += ` ‚Ä¢ ${qa.metadata.traceTypes.join(', ')}`;
                        }
                        answerDiv.appendChild(metaDiv);
                    }
                }
                
                qaDiv.appendChild(questionDiv);
                qaDiv.appendChild(answerDiv);
                transcript.appendChild(qaDiv);
            });

            transcript.scrollTop = transcript.scrollHeight;
        }

        function clearTranscript() {
            log('Clearing transcript');
            qaResults = [];
            updateTranscriptDisplay();
            addSystemMessage('Transcript cleared');
            updateStats();
        }

        function copyToClipboard() {
            let text = '=== VOICEFLOW TEST RESULTS ===\n\n';
            
            qaResults.forEach((qa, index) => {
                text += `Q${index + 1}: ${qa.question}\n`;
                text += `A${index + 1}: ${qa.answer}\n\n`;
            });
            
            navigator.clipboard.writeText(text).then(() => {
                addSystemMessage('üìã Copied to clipboard');
            });
        }

        // Initialize
        window.addEventListener('load', () => {
            log('=== Page Loaded ===');
            addSystemMessage('ü§ñ Chatbot Tester v5.4 - Testing Basic Agent');
            addSystemMessage('Press F12 to see detailed console logs');
            addSystemMessage('Step 1: Enter API Key');
            addSystemMessage('Step 2: Load questions');
            addSystemMessage('Step 3: Test connection (recommended)');
            addSystemMessage('Step 4: Start test');
            
            // Add listeners
            const apiKeyInput = document.getElementById('apiKey');
            apiKeyInput.addEventListener('input', () => {
                log('API key changed');
                checkReadyToTest();
            });
            
            log('Initialization complete');
        });
    </script>
</body>
</html>
