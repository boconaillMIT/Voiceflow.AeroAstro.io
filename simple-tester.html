<!DOCTYPE html>
<html>
<head>
    <title>Voiceflow Chatbot Tester v7.0 - QuickBase Integration</title>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 20px; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }
        .header h1 {
            margin: 0;
            font-size: 32px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        .header p {
            margin: 5px 0;
            opacity: 0.9;
        }
        .container { 
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 400px 1fr 500px;
            gap: 20px;
            min-height: 80vh;
        }
        .panel { 
            background: white; 
            padding: 25px; 
            border-radius: 12px; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        .panel h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        .input-group {
            margin: 15px 0;
        }
        .input-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        input[type="text"], textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }
        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: #007bff;
        }
        textarea {
            min-height: 150px;
            resize: vertical;
        }
        button { 
            background: #007bff; 
            color: white; 
            border: none; 
            padding: 12px 20px; 
            border-radius: 6px; 
            cursor: pointer; 
            margin: 5px 0;
            width: 100%;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,123,255,0.3);
        }
        button:hover { 
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,123,255,0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled { 
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button.green { 
            background: #28a745;
            box-shadow: 0 2px 8px rgba(40,167,69,0.3);
        }
        button.green:hover { 
            background: #218838;
            box-shadow: 0 4px 12px rgba(40,167,69,0.4);
        }
        button.orange { 
            background: #fd7e14;
            box-shadow: 0 2px 8px rgba(253,126,20,0.3);
        }
        button.orange:hover { 
            background: #e8590c;
            box-shadow: 0 4px 12px rgba(253,126,20,0.4);
        }
        button.red { 
            background: #dc3545;
            box-shadow: 0 2px 8px rgba(220,53,69,0.3);
        }
        button.red:hover { 
            background: #c82333;
            box-shadow: 0 4px 12px rgba(220,53,69,0.4);
        }
        button.gray { 
            background: #6c757d;
            box-shadow: 0 2px 8px rgba(108,117,125,0.3);
        }
        button.gray:hover { 
            background: #5a6268;
            box-shadow: 0 4px 12px rgba(108,117,125,0.4);
        }
        button.purple {
            background: #6f42c1;
            box-shadow: 0 2px 8px rgba(111,66,193,0.3);
        }
        button.purple:hover {
            background: #5a32a3;
            box-shadow: 0 4px 12px rgba(111,66,193,0.4);
        }
        .status {
            padding: 12px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 14px;
            font-weight: 500;
        }
        .status.info { background: #d1ecf1; color: #0c5460; border-left: 4px solid #17a2b8; }
        .status.success { background: #d4edda; color: #155724; border-left: 4px solid #28a745; }
        .status.error { background: #f8d7da; color: #721c24; border-left: 4px solid #dc3545; }
        .status.warning { background: #fff3cd; color: #856404; border-left: 4px solid #ffc107; }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(102,126,234,0.3);
        }
        .stat-card h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            opacity: 0.9;
            text-transform: uppercase;
        }
        .stat-card .number {
            font-size: 32px;
            font-weight: bold;
            margin: 0;
        }
        .question-list {
            max-height: 300px;
            overflow-y: auto;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            margin: 15px 0;
        }
        .question-item {
            padding: 10px;
            margin: 5px 0;
            background: #f8f9fa;
            border-left: 3px solid #007bff;
            border-radius: 4px;
            font-size: 13px;
        }
        .question-item.completed {
            background: #d4edda;
            border-left-color: #28a745;
        }
        .question-item.error {
            background: #f8d7da;
            border-left-color: #dc3545;
        }
        .question-item.active {
            background: #fff3cd;
            border-left-color: #ffc107;
            font-weight: bold;
        }
        .transcript {
            background: #f8f9fa;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            min-height: 600px;
            max-height: 800px;
            overflow-y: auto;
            font-size: 14px;
        }
        .qa-pair {
            margin: 20px 0;
            padding: 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .qa-question {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .qa-question .number {
            background: rgba(255,255,255,0.2);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        .qa-answer {
            background: #f8f9fa;
            color: #333;
            padding: 15px;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        .qa-answer.error {
            background: #f8d7da;
            color: #721c24;
        }
        .qa-waiting {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            font-style: italic;
        }
        .qa-metadata {
            font-size: 12px;
            color: #6c757d;
            padding: 10px 15px;
            background: #f1f3f5;
            border-top: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
        }
        .system-message {
            padding: 10px;
            margin: 8px 0;
            background: #e7f3ff;
            border-left: 3px solid #007bff;
            border-radius: 4px;
            font-size: 13px;
            color: #004085;
        }
        .system-message.error {
            background: #f8d7da;
            border-left-color: #dc3545;
            color: #721c24;
        }
        .system-message.success {
            background: #d4edda;
            border-left-color: #28a745;
            color: #155724;
        }
        .system-message.warning {
            background: #fff3cd;
            border-left-color: #ffc107;
            color: #856404;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 15px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        .version-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 12px;
            margin-top: 5px;
        }
        .diagnostic-log {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 600px;
            overflow-y: auto;
            margin: 15px 0;
            line-height: 1.4;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid transparent;
        }
        .log-entry.info { 
            color: #4fc3f7;
            border-left-color: #4fc3f7;
        }
        .log-entry.success { 
            color: #66bb6a;
            border-left-color: #66bb6a;
        }
        .log-entry.error { 
            color: #ef5350;
            border-left-color: #ef5350;
        }
        .log-entry.warning { 
            color: #ffca28;
            border-left-color: #ffca28;
        }
        .log-entry .timestamp {
            color: #888;
            font-size: 11px;
        }
        .endpoint-test {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 13px;
        }
        .endpoint-test.testing {
            border-color: #ffc107;
            background: #fff3cd;
        }
        .endpoint-test.success {
            border-color: #28a745;
            background: #d4edda;
        }
        .endpoint-test.failed {
            border-color: #dc3545;
            background: #f8d7da;
        }
        .endpoint-url {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #666;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔬 Voiceflow Chatbot Tester</h1>
        <p>Automated Testing with QuickBase Logging</p>
        <span class="version-badge">v7.0 QuickBase Integration</span>
    </div>

    <div class="container">
        <!-- Left Panel: Controls -->
        <div class="panel">
            <h3>⚙️ Configuration</h3>
            
            <div class="input-group">
                <label for="apiKeySelect">🔑 Select API Key:</label>
                <select id="apiKeySelect" onchange="loadSelectedApiKey()">
                    <option value="">-- Select API Key --</option>
                    <option value="VF.DM.66df267d16a91c9f126fab7e.pZsTqAbO2vhQgVNa">Production Agent (Working)</option>
                    <option value="custom">Custom (enter below)</option>
                </select>
            </div>

            <div class="input-group">
                <label for="apiKey">Or Enter Custom API Key:</label>
                <input type="text" id="apiKey" placeholder="VF.DM.xxxxx.xxxxxx" />
                <small style="color: #666; font-size: 12px;">Get from: Settings → API Keys</small>
            </div>

            <div class="input-group">
                <label for="projectId">🆔 Project ID (Optional):</label>
                <input type="text" id="projectId" placeholder="Leave blank for auto-detection" />
                <small style="color: #666; font-size: 12px;">Only needed for v2 endpoint testing</small>
            </div>

            <div class="input-group">
                <label for="versionId">📦 Agent Version:</label>
                <select id="versionId">
                    <option value="production">Production (published)</option>
                    <option value="development">Development (draft)</option>
                </select>
                <small style="color: #666; font-size: 12px;">Try Development if Production fails</small>
            </div>

            <hr style="margin: 20px 0; border: none; border-top: 1px solid #e0e0e0;">

            <h3>📊 QuickBase Configuration</h3>
            
            <div class="input-group">
                <label for="qbEnabled">Enable QuickBase Logging:</label>
                <input type="checkbox" id="qbEnabled" checked style="width: auto; margin: 10px 0;" />
                <small style="color: #666; font-size: 12px;">Log all Q&As to QuickBase database</small>
            </div>

            <div class="input-group">
                <label for="qbRealm">QB Realm:</label>
                <input type="text" id="qbRealm" value="mit.quickbase.com" />
            </div>

            <div class="input-group">
                <label for="qbToken">QB User Token:</label>
                <input type="text" id="qbToken" value="b4bqn2_bkcg_0_cjj8hwibg9qrcyx9fm2qiqa5h" />
                <small style="color: #666; font-size: 12px;">From: My Preferences → Manage User Tokens</small>
            </div>

            <div class="input-group">
                <label for="qbTableId">QB Table ID:</label>
                <input type="text" id="qbTableId" value="bvi4py32v" />
                <small style="color: #666; font-size: 12px;">From table URL: /db/bxxxxxxxx</small>
            </div>

            <div id="qbStatus" class="status info" style="font-size: 12px;">
                📊 QuickBase ready - will log after each Q&A
            </div>

            <button onclick="testQuickBaseConnection()" class="gray" style="font-size: 12px;">🧪 Test QB Connection</button>

            <hr style="margin: 20px 0; border: none; border-top: 1px solid #e0e0e0;">

            <button onclick="runFullDiagnostic()" class="purple">🔬 Run Full Diagnostic</button>
            <button onclick="testConnection()" class="orange">🔌 Quick Connection Test</button>

            <div id="statusDiv" class="status info">
                💡 Enter API key and run diagnostic to find working endpoint
            </div>

            <hr style="margin: 20px 0; border: none; border-top: 1px solid #e0e0e0;">

            <h3>📝 Test Questions</h3>
            
            <div class="input-group">
                <label for="questions">Enter questions (one per line):</label>
                <textarea id="questions" placeholder="who is the department head&#10;how can i create a budget?&#10;how do i request a waiver"></textarea>
            </div>

            <button onclick="loadQuestions()" class="green">📥 Load Questions</button>
            <button onclick="loadSampleQuestions()" class="gray">📋 Load Sample Questions</button>

            <hr style="margin: 20px 0; border: none; border-top: 1px solid #e0e0e0;">

            <h3>📊 Or Load from Google Sheets</h3>
            
            <div class="input-group">
                <label for="googleSheetId">Google Sheet ID:</label>
                <input type="text" id="googleSheetId" placeholder="1flnWLAXZGoTpDjkRMuuD3LvyphYIij0gruCu_4x__gQ" value="1flnWLAXZGoTpDjkRMuuD3LvyphYIij0gruCu_4x__gQ" />
                <small style="color: #666; font-size: 12px;">From sheet URL: docs.google.com/spreadsheets/d/[ID]/edit</small>
            </div>

            <div class="input-group">
                <label for="googleSheetGid">Sheet GID (Optional):</label>
                <input type="text" id="googleSheetGid" placeholder="0" />
                <small style="color: #666; font-size: 12px;">From URL: #gid=123456 (leave blank for first sheet)</small>
            </div>

            <button onclick="loadFromGoogleSheets()" class="orange">📊 Load from Google Sheets</button>

            <div class="progress-bar">
                <div id="progressBar" class="progress-fill" style="width: 0%"></div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <h4>Total Questions</h4>
                    <p class="number" id="totalCount">0</p>
                </div>
                <div class="stat-card">
                    <h4>Completed</h4>
                    <p class="number" id="completedCount">0</p>
                </div>
            </div>

            <div id="questionList" class="question-list"></div>

            <hr style="margin: 20px 0; border: none; border-top: 1px solid #e0e0e0;">

            <h3>🚀 Actions</h3>
            
            <button id="startBtn" onclick="startTest()" disabled>▶️ Start Test</button>
            <button id="stopBtn" onclick="stopTest()" class="red" disabled>⏹️ Stop Test</button>
            
            <div class="button-group">
                <button onclick="clearTranscript()" class="gray">🗑️ Clear</button>
                <button onclick="copyToClipboard()" class="gray">📋 Copy</button>
            </div>
            
            <button onclick="exportToCSV()" class="green">📊 Export CSV</button>
            <button onclick="copyDiagnosticLog()" class="gray">📋 Copy Diagnostic Log</button>
        </div>

        <!-- Middle Panel: Transcript -->
        <div class="panel">
            <h3>📜 Test Transcript</h3>
            <div id="transcript" class="transcript"></div>
        </div>

        <!-- Right Panel: Diagnostic Log -->
        <div class="panel">
            <h3>🔬 Diagnostic Log</h3>
            <div id="diagnosticLog" class="diagnostic-log"></div>
            
            <hr style="margin: 20px 0; border: none; border-top: 1px solid #e0e0e0;">
            
            <h3>🌐 Endpoint Test Results</h3>
            <div id="endpointResults"></div>
        </div>
    </div>

    <script>
        console.log('🚀 Voiceflow Tester v7.0 - QuickBase Integration');
        
        // Load selected API key from dropdown
        function loadSelectedApiKey() {
            const select = document.getElementById('apiKeySelect');
            const apiKeyInput = document.getElementById('apiKey');
            const selectedValue = select.value;
            
            if (selectedValue && selectedValue !== 'custom') {
                apiKeyInput.value = selectedValue;
                addDiagnosticLog(`Loaded API key: ${select.options[select.selectedIndex].text}`, 'info');
                
                // Auto-extract project ID
                const extractedId = extractProjectId(selectedValue);
                if (extractedId && !document.getElementById('projectId').value) {
                    document.getElementById('projectId').value = extractedId;
                    addDiagnosticLog(`Auto-detected Project ID: ${extractedId}`, 'info');
                }
                
                checkReadyToTest();
            } else if (selectedValue === 'custom') {
                apiKeyInput.focus();
            }
        }
        
        // Global variables
        let questions = [];
        let currentQuestionIndex = 0;
        let qaResults = [];
        let isTesting = false;
        let currentUserId = null;
        let workingEndpoint = null;
        let diagnosticHistory = [];
        
        // API Endpoints to test
        const API_ENDPOINTS = {
            v1: {
                name: 'V1 State API',
                baseUrl: 'https://general-runtime.voiceflow.com/state/user',
                buildUrl: (userId) => `https://general-runtime.voiceflow.com/state/user/${userId}/interact`,
                headers: (apiKey, versionId) => ({
                    'Authorization': apiKey,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'versionID': versionId || 'production'
                })
            },
            v2: {
                name: 'V2 Project API',
                baseUrl: 'https://general-runtime.voiceflow.com',
                buildUrl: (userId, projectId) => `https://general-runtime.voiceflow.com/v2/project/${projectId}/user/${userId}/interact`,
                headers: (apiKey, versionId) => ({
                    'Authorization': apiKey,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'versionID': versionId || 'production'
                }),
                requiresProjectId: true
            },
            dm: {
                name: 'DM API (Alternative)',
                baseUrl: 'https://general-runtime.voiceflow.com/state/user',
                buildUrl: (userId) => `https://general-runtime.voiceflow.com/state/user/${userId}/interact`,
                headers: (apiKey, versionId) => ({
                    'Authorization': apiKey,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'versionID': versionId || 'production'
                })
            }
        };

        // QuickBase Integration
        async function writeToQuickBase(question, answer, metadata = {}) {
            // Check if QB logging is enabled
            if (!document.getElementById('qbEnabled').checked) {
                addDiagnosticLog('QuickBase logging disabled - skipping', 'info');
                return { success: true, skipped: true };
            }

            const realm = document.getElementById('qbRealm').value.trim();
            const token = document.getElementById('qbToken').value.trim();
            const tableId = document.getElementById('qbTableId').value.trim();

            if (!realm || !token || !tableId) {
                addDiagnosticLog('QuickBase config incomplete - skipping write', 'warning');
                return { success: false, error: 'Incomplete config' };
            }

            // Generate test run ID if not provided
            const testRunId = metadata.testRunId || `test_${new Date().toISOString().split('T')[0]}_${Date.now()}`;

            // Build QuickBase API request
            const qbUrl = `https://api.quickbase.com/v1/records`;
            const qbHeaders = {
                'QB-Realm-Hostname': realm,
                'Authorization': `QB-USER-TOKEN ${token}`,
                'Content-Type': 'application/json'
            };

            const qbBody = {
                "to": tableId,
                "data": [
                    {
                        "6": {"value": question},           // question field
                        "7": {"value": answer},            // answer field
                        "8": {"value": metadata.source || "tester"},  // source field
                        "9": {"value": "pending"},         // status field
                        "10": {"value": new Date().toISOString()},  // date_time field
                        "11": {"value": metadata.responseTime || 0}, // response_time_ms field
                        "12": {"value": testRunId},        // test_run_id field
                        "13": {"value": metadata.flaggedBy || ""}, // flagged_by field
                        "14": {"value": metadata.suggestedCorrection || ""}, // suggested_correction field
                        "15": {"value": metadata.adminNotes || ""}, // admin_notes field
                        "16": {"value": false}             // reviewed field
                    }
                ],
                "fieldsToReturn": [3]  // Return record ID
            };

            addDiagnosticLog('Writing to QuickBase...', 'info', {
                table: tableId,
                question: question.substring(0, 50) + '...',
                answer: answer.substring(0, 50) + '...'
            });

            try {
                const response = await fetch(qbUrl, {
                    method: 'POST',
                    headers: qbHeaders,
                    body: JSON.stringify(qbBody)
                });

                const responseData = await response.json();

                if (response.ok) {
                    const recordId = responseData.data?.[0]?.[3]?.value || 'unknown';
                    addDiagnosticLog(`✅ QuickBase write successful - Record ID: ${recordId}`, 'success');
                    updateQBStatus(`✅ Last write: ${new Date().toLocaleTimeString()}`, 'success');
                    return { success: true, recordId, data: responseData };
                } else {
                    addDiagnosticLog(`❌ QuickBase write failed: ${response.status}`, 'error', responseData);
                    updateQBStatus(`❌ Write failed: ${response.status}`, 'error');
                    return { success: false, status: response.status, error: responseData };
                }
            } catch (error) {
                addDiagnosticLog(`❌ QuickBase error: ${error.message}`, 'error');
                updateQBStatus(`❌ Error: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }

        // Update QuickBase status display
        function updateQBStatus(message, type = 'info') {
            const qbStatus = document.getElementById('qbStatus');
            qbStatus.className = `status ${type}`;
            qbStatus.textContent = message;
        }

        // Test QuickBase connection
        async function testQuickBaseConnection() {
            addDiagnosticLog('Testing QuickBase connection...', 'info');
            updateQBStatus('🔄 Testing connection...', 'info');
            
            const testQuestion = "Test question from tester";
            const testAnswer = `Test answer - ${new Date().toLocaleString()}`;
            
            const result = await writeToQuickBase(testQuestion, testAnswer, {
                source: 'tester',
                responseTime: 0,
                adminNotes: 'This is a test record - safe to delete'
            });
            
            if (result.success) {
                if (result.skipped) {
                    updateQBStatus('⚠️ QB logging is disabled', 'warning');
                    setStatus('QuickBase logging is disabled - enable it to test', 'warning');
                } else {
                    updateQBStatus(`✅ Connection successful! Record ID: ${result.recordId}`, 'success');
                    setStatus('✅ QuickBase connection verified!', 'success');
                    addSystemMessage('QuickBase test record created successfully');
                }
            } else {
                updateQBStatus(`❌ Connection failed: ${result.error}`, 'error');
                setStatus(`❌ QuickBase connection failed: ${result.error}`, 'error');
                addSystemMessage('QuickBase connection test failed', true);
            }
        }

        // Diagnostic logging
        function addDiagnosticLog(message, type = 'info', data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                timestamp,
                message,
                type,
                data
            };
            
            diagnosticHistory.push(logEntry);
            
            const logDiv = document.getElementById('diagnosticLog');
            const entryDiv = document.createElement('div');
            entryDiv.className = `log-entry ${type}`;
            
            let logText = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            if (data) {
                logText += `\n${JSON.stringify(data, null, 2)}`;
            }
            
            entryDiv.innerHTML = logText.replace(/\n/g, '<br>');
            logDiv.appendChild(entryDiv);
            logDiv.scrollTop = logDiv.scrollHeight;
            
            // Also log to console
            console.log(`[${timestamp}] [${type.toUpperCase()}] ${message}`, data || '');
        }

        // Status message display
        function setStatus(message, type = 'info') {
            const statusDiv = document.getElementById('statusDiv');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            addDiagnosticLog(`Status: ${message}`, type);
        }

        // System message in transcript
        function addSystemMessage(message, isError = false) {
            const transcript = document.getElementById('transcript');
            const msgDiv = document.createElement('div');
            msgDiv.className = `system-message ${isError ? 'error' : 'success'}`;
            msgDiv.textContent = `${isError ? '❌' : '✅'} ${message}`;
            transcript.appendChild(msgDiv);
            transcript.scrollTop = transcript.scrollHeight;
        }

        // Extract project ID from API key
        function extractProjectId(apiKey) {
            // VF.DM.{projectId}.{token}
            const parts = apiKey.split('.');
            if (parts.length >= 3 && parts[0] === 'VF' && parts[1] === 'DM') {
                return parts[2];
            }
            return null;
        }

        // Test a specific endpoint
        async function testEndpoint(endpointKey, endpoint, apiKey, projectId = null, versionId = 'production') {
            addDiagnosticLog(`Testing ${endpoint.name} with version: ${versionId}...`, 'info');
            
            const resultsDiv = document.getElementById('endpointResults');
            const testDiv = document.createElement('div');
            testDiv.className = 'endpoint-test testing';
            testDiv.id = `endpoint-${endpointKey}`;
            testDiv.innerHTML = `
                <strong>🔄 ${endpoint.name} (${versionId})</strong><br>
                <div class="endpoint-url">Testing...</div>
            `;
            resultsDiv.appendChild(testDiv);
            
            try {
                const testUserId = 'diagnostic_' + Date.now();
                
                // Skip if requires project ID but we don't have one
                if (endpoint.requiresProjectId && !projectId) {
                    testDiv.className = 'endpoint-test failed';
                    testDiv.innerHTML = `
                        <strong>⚠️ ${endpoint.name}</strong><br>
                        <div class="endpoint-url">Skipped - No Project ID provided</div>
                    `;
                    addDiagnosticLog(`${endpoint.name} skipped - requires Project ID`, 'warning');
                    return { success: false, reason: 'No Project ID' };
                }
                
                const url = endpoint.requiresProjectId 
                    ? endpoint.buildUrl(testUserId, projectId)
                    : endpoint.buildUrl(testUserId);
                
                testDiv.querySelector('.endpoint-url').textContent = url;
                
                addDiagnosticLog(`Request URL: ${url}`, 'info');
                const headers = endpoint.headers(apiKey, versionId);
                addDiagnosticLog(`Headers:`, 'info', headers);
                
                const requestBody = {
                    action: {
                        type: 'launch'
                    }
                };
                
                addDiagnosticLog(`Request Body:`, 'info', requestBody);
                
                const startTime = Date.now();
                const response = await fetch(url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });
                
                const responseTime = Date.now() - startTime;
                
                addDiagnosticLog(`Response Status: ${response.status} ${response.statusText}`, 
                    response.ok ? 'success' : 'error');
                addDiagnosticLog(`Response Time: ${responseTime}ms`, 'info');
                
                // Get response body
                const responseText = await response.text();
                let responseData;
                
                try {
                    responseData = JSON.parse(responseText);
                    addDiagnosticLog(`Response Body:`, response.ok ? 'success' : 'error', responseData);
                } catch (e) {
                    addDiagnosticLog(`Response Body (raw): ${responseText.substring(0, 500)}`, 'error');
                    responseData = { error: 'Invalid JSON', raw: responseText };
                }
                
                if (response.ok) {
                    testDiv.className = 'endpoint-test success';
                    testDiv.innerHTML = `
                        <strong>✅ ${endpoint.name} (${versionId})</strong><br>
                        <div class="endpoint-url">${url}</div>
                        <div style="margin-top: 8px; font-size: 12px; color: #155724;">
                            Status: ${response.status} | Time: ${responseTime}ms
                        </div>
                    `;
                    addDiagnosticLog(`✅ ${endpoint.name} WORKS!`, 'success');
                    return { success: true, endpoint: endpointKey, url, responseTime, data: responseData };
                } else {
                    testDiv.className = 'endpoint-test failed';
                    testDiv.innerHTML = `
                        <strong>❌ ${endpoint.name} (${versionId})</strong><br>
                        <div class="endpoint-url">${url}</div>
                        <div style="margin-top: 8px; font-size: 12px; color: #721c24;">
                            Status: ${response.status} ${response.statusText}
                        </div>
                    `;
                    addDiagnosticLog(`❌ ${endpoint.name} failed: ${response.status} ${response.statusText}`, 'error');
                    return { success: false, status: response.status, error: responseData };
                }
            } catch (error) {
                testDiv.className = 'endpoint-test failed';
                testDiv.innerHTML = `
                    <strong>❌ ${endpoint.name}</strong><br>
                    <div class="endpoint-url">Error: ${error.message}</div>
                `;
                addDiagnosticLog(`❌ ${endpoint.name} exception: ${error.message}`, 'error', error);
                return { success: false, error: error.message };
            }
        }

        // Run full diagnostic
        async function runFullDiagnostic() {
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (!apiKey) {
                setStatus('❌ Please enter API key first', 'error');
                return;
            }
            
            // Clear previous results
            document.getElementById('endpointResults').innerHTML = '';
            diagnosticHistory = [];
            document.getElementById('diagnosticLog').innerHTML = '';
            
            setStatus('🔬 Running full diagnostic...', 'info');
            addDiagnosticLog('=== FULL DIAGNOSTIC TEST STARTED ===', 'info');
            addDiagnosticLog(`API Key: ${apiKey.substring(0, 20)}...`, 'info');
            
            // Extract or get project ID
            let projectId = document.getElementById('projectId').value.trim();
            if (!projectId) {
                projectId = extractProjectId(apiKey);
                if (projectId) {
                    addDiagnosticLog(`Extracted Project ID from API key: ${projectId}`, 'success');
                    document.getElementById('projectId').value = projectId;
                } else {
                    addDiagnosticLog(`No Project ID found in API key`, 'warning');
                }
            } else {
                addDiagnosticLog(`Using provided Project ID: ${projectId}`, 'info');
            }
            
            // Get version ID
            const versionId = document.getElementById('versionId').value;
            addDiagnosticLog(`Testing with version: ${versionId}`, 'info');
            
            // Test all endpoints
            const results = [];
            
            for (const [key, endpoint] of Object.entries(API_ENDPOINTS)) {
                const result = await testEndpoint(key, endpoint, apiKey, projectId, versionId);
                results.push({ key, ...result });
                
                // Small delay between tests
                await sleep(500);
            }
            
            // Analyze results
            const workingEndpoints = results.filter(r => r.success);
            
            addDiagnosticLog('=== DIAGNOSTIC TEST COMPLETE ===', 'info');
            
            if (workingEndpoints.length > 0) {
                workingEndpoint = workingEndpoints[0];
                setStatus(`✅ Found working endpoint: ${API_ENDPOINTS[workingEndpoint.key].name}`, 'success');
                addDiagnosticLog(`✅ Working endpoint found: ${workingEndpoint.key}`, 'success', workingEndpoint);
                addSystemMessage(`Diagnostic complete - using ${API_ENDPOINTS[workingEndpoint.key].name}`);
                checkReadyToTest();
            } else {
                workingEndpoint = null;
                setStatus('❌ No working endpoints found. Check diagnostic log for details.', 'error');
                addDiagnosticLog('❌ NO WORKING ENDPOINTS FOUND', 'error');
                addSystemMessage('Diagnostic failed - no endpoints working', true);
                
                // Provide helpful suggestions
                addDiagnosticLog('=== TROUBLESHOOTING SUGGESTIONS ===', 'warning');
                addDiagnosticLog('1. Verify API key is correct and active', 'warning');
                addDiagnosticLog('2. Check if Project ID is required and correct', 'warning');
                addDiagnosticLog('3. Verify agent is published and not in draft mode', 'warning');
                addDiagnosticLog('4. Check Voiceflow dashboard for API errors', 'warning');
                addDiagnosticLog('5. Try generating a new API key', 'warning');
            }
            
            // Show summary
            const summary = {
                total: results.length,
                working: workingEndpoints.length,
                failed: results.length - workingEndpoints.length
            };
            addDiagnosticLog(`Summary: ${summary.working}/${summary.total} endpoints working`, 
                summary.working > 0 ? 'success' : 'error', summary);
        }

        // Quick connection test (uses first working endpoint or v1)
        async function testConnection() {
            const apiKey = document.getElementById('apiKey').value.trim();
            
            if (!apiKey) {
                setStatus('❌ Please enter API key first', 'error');
                return;
            }

            setStatus('🔄 Testing connection...', 'info');
            
            // Use working endpoint if available, otherwise try v1
            const endpointKey = workingEndpoint ? workingEndpoint.key : 'v1';
            const endpoint = API_ENDPOINTS[endpointKey];
            const projectId = document.getElementById('projectId').value.trim() || extractProjectId(apiKey);
            const versionId = document.getElementById('versionId').value;
            
            const result = await testEndpoint(endpointKey, endpoint, apiKey, projectId, versionId);
            
            if (result.success) {
                workingEndpoint = { key: endpointKey, ...result };
                setStatus('✅ Connection successful!', 'success');
                addSystemMessage('API connection verified');
                checkReadyToTest();
            } else {
                setStatus('❌ Connection failed. Run full diagnostic for details.', 'error');
                addSystemMessage('Connection failed - try full diagnostic', true);
            }
        }

        // Load questions from Google Sheets
        async function loadFromGoogleSheets() {
            const sheetId = document.getElementById('googleSheetId').value.trim();
            const gid = document.getElementById('googleSheetGid').value.trim() || '0';
            
            if (!sheetId) {
                setStatus('❌ Please enter a Google Sheet ID', 'error');
                return;
            }
            
            setStatus('🔄 Loading from Google Sheets...', 'info');
            addDiagnosticLog(`Loading questions from Sheet ID: ${sheetId}, GID: ${gid}`, 'info');
            
            try {
                const csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gid}`;
                addDiagnosticLog(`Fetching URL: ${csvUrl}`, 'info');
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                const response = await fetch(csvUrl, {
                    signal: controller.signal,
                    mode: 'cors'
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status} - Sheet may not be published or accessible`);
                }
                
                const csvText = await response.text();
                addDiagnosticLog(`Received ${csvText.length} characters of CSV data`, 'info');
                
                if (!csvText.trim()) {
                    throw new Error('Empty response from Google Sheets');
                }
                
                // Parse CSV - questions in first column
                const lines = csvText.split('\n');
                const newQuestions = lines
                    .slice(1) // Skip header row
                    .map(line => {
                        const firstComma = line.indexOf(',');
                        return firstComma === -1 ? line : line.substring(0, firstComma);
                    })
                    .filter(q => q && q.trim())
                    .map(q => q.replace(/"/g, '').trim());
                
                if (newQuestions.length === 0) {
                    throw new Error('No questions found in first column');
                }
                
                // Update textarea and load questions
                document.getElementById('questions').value = newQuestions.join('\n');
                questions = newQuestions;
                
                addDiagnosticLog(`Successfully loaded ${questions.length} questions from Google Sheets`, 'success', questions);
                setStatus(`✅ Loaded ${questions.length} questions from Google Sheets`, 'success');
                addSystemMessage(`Loaded ${questions.length} questions from Google Sheets`);
                
                displayQuestions();
                updateStats();
                checkReadyToTest();
                
            } catch (error) {
                let errorMsg = error.message;
                if (error.name === 'AbortError') {
                    errorMsg = 'Request timed out after 10 seconds';
                }
                
                addDiagnosticLog(`Google Sheets error: ${errorMsg}`, 'error');
                setStatus(`❌ Google Sheets failed: ${errorMsg}`, 'error');
                addSystemMessage(`Failed to load from Google Sheets: ${errorMsg}`, true);
                
                // Provide troubleshooting tips
                if (error.message.includes('403') || error.message.includes('404')) {
                    addSystemMessage('💡 Make sure sheet is published: File → Share → Publish to web', true);
                }
            }
        }

        // Load questions from textarea
        function loadQuestions() {
            const textarea = document.getElementById('questions');
            const text = textarea.value.trim();
            
            if (!text) {
                setStatus('❌ Please enter some questions', 'error');
                return;
            }

            questions = text.split('\n')
                .map(q => q.trim())
                .filter(q => q.length > 0);
            
            addDiagnosticLog(`Loaded ${questions.length} questions`, 'success', questions);
            
            setStatus(`✅ Loaded ${questions.length} questions`, 'success');
            addSystemMessage(`Loaded ${questions.length} questions`);
            
            displayQuestions();
            updateStats();
            checkReadyToTest();
        }

        // Load sample questions
        function loadSampleQuestions() {
            const samples = [
                "who is the department head",
                "who is the DAF",
                "how can i create a budget?",
                "how do i request a waiver",
                "how do i request a proposal waiver"
            ];
            
            document.getElementById('questions').value = samples.join('\n');
            loadQuestions();
        }

        // Display questions in list
        function displayQuestions() {
            const list = document.getElementById('questionList');
            list.innerHTML = '';
            
            questions.forEach((q, index) => {
                const item = document.createElement('div');
                item.className = 'question-item';
                item.id = `question-${index}`;
                item.textContent = `${index + 1}. ${q}`;
                list.appendChild(item);
            });
        }

        // Update statistics
        function updateStats() {
            document.getElementById('totalCount').textContent = questions.length;
            document.getElementById('completedCount').textContent = qaResults.length;
            
            const progress = questions.length > 0 ? (qaResults.length / questions.length) * 100 : 0;
            document.getElementById('progressBar').style.width = progress + '%';
        }

        // Check if ready to start testing
        function checkReadyToTest() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const hasQuestions = questions.length > 0;
            const hasApiKey = apiKey.length > 0;
            const hasWorkingEndpoint = workingEndpoint !== null;
            
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = !(hasQuestions && hasApiKey && hasWorkingEndpoint);
            
            if (hasQuestions && hasApiKey && hasWorkingEndpoint) {
                setStatus('✅ Ready to start testing!', 'success');
            } else if (hasQuestions && hasApiKey && !hasWorkingEndpoint) {
                setStatus('⚠️ Run diagnostic to find working endpoint', 'warning');
            }
        }

        // Start testing
        async function startTest() {
            if (isTesting || !workingEndpoint) return;
            
            isTesting = true;
            currentQuestionIndex = 0;
            qaResults = [];
            currentUserId = 'user_' + Date.now();
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            setStatus('🚀 Starting test...', 'info');
            addSystemMessage('Test started');
            addDiagnosticLog(`=== TEST STARTED ===`, 'info');
            addDiagnosticLog(`User ID: ${currentUserId}`, 'info');
            addDiagnosticLog(`Using endpoint: ${API_ENDPOINTS[workingEndpoint.key].name}`, 'info');
            
            // Launch conversation
            await launchConversation();
            
            // Process questions
            for (let i = 0; i < questions.length; i++) {
                if (!isTesting) break;
                
                currentQuestionIndex = i;
                await askQuestion(questions[i], i);
                
                // Wait between questions
                if (i < questions.length - 1) {
                    await sleep(1000);
                }
            }
            
            if (isTesting) {
                setStatus('✅ Test completed!', 'success');
                addSystemMessage('All questions completed');
                addDiagnosticLog('=== TEST COMPLETED ===', 'success');
            }
            
            stopTest();
        }

        // Launch conversation
        async function launchConversation() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const endpoint = API_ENDPOINTS[workingEndpoint.key];
            const projectId = document.getElementById('projectId').value.trim();
            const versionId = document.getElementById('versionId').value;
            
            try {
                addDiagnosticLog('Launching conversation...', 'info');
                
                const url = endpoint.requiresProjectId 
                    ? endpoint.buildUrl(currentUserId, projectId)
                    : endpoint.buildUrl(currentUserId);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: endpoint.headers(apiKey, versionId),
                    body: JSON.stringify({
                        action: { type: 'launch' }
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    addDiagnosticLog('Conversation launched successfully', 'success', data);
                } else {
                    const errorData = await response.text();
                    addDiagnosticLog(`Launch warning: ${response.status}`, 'warning', errorData);
                }
            } catch (error) {
                addDiagnosticLog(`Launch error: ${error.message}`, 'error');
            }
        }

        // Ask a question
        async function askQuestion(question, index) {
            const apiKey = document.getElementById('apiKey').value.trim();
            const endpoint = API_ENDPOINTS[workingEndpoint.key];
            const projectId = document.getElementById('projectId').value.trim();
            const versionId = document.getElementById('versionId').value;
            const questionItem = document.getElementById(`question-${index}`);
            
            if (questionItem) {
                questionItem.classList.add('active');
            }
            
            // Add question to transcript
            addQuestionToTranscript(question, index);
            
            const startTime = Date.now();
            
            try {
                addDiagnosticLog(`Asking Q${index + 1}: ${question}`, 'info');
                
                const url = endpoint.requiresProjectId 
                    ? endpoint.buildUrl(currentUserId, projectId)
                    : endpoint.buildUrl(currentUserId);
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: endpoint.headers(apiKey, versionId),
                    body: JSON.stringify({
                        action: {
                            type: 'text',
                            payload: question
                        }
                    })
                });

                const responseTime = Date.now() - startTime;
                
                if (response.ok) {
                    const data = await response.json();
                    addDiagnosticLog(`Response Q${index + 1} received (${responseTime}ms)`, 'success', data);
                    
                    // Extract answer
                    const answer = extractAnswer(data);
                    
                    // Store result
                    const result = {
                        question,
                        answer,
                        responseTime,
                        rawData: data
                    };
                    
                    qaResults.push(result);
                    
                    // Write to QuickBase
                    await writeToQuickBase(question, answer, {
                        responseTime: responseTime,
                        source: 'tester',
                        testRunId: `test_${Date.now()}`
                    });
                    
                    // Update UI
                    updateAnswerInTranscript(index, answer, responseTime);
                    
                    if (questionItem) {
                        questionItem.classList.remove('active');
                        questionItem.classList.add('completed');
                    }
                } else {
                    const errorText = await response.text();
                    addDiagnosticLog(`Error Q${index + 1}: ${response.status} ${response.statusText}`, 'error', errorText);
                    
                    const errorMsg = `API Error: ${response.status} - ${errorText.substring(0, 100)}`;
                    updateAnswerInTranscript(index, errorMsg, responseTime, true);
                    
                    if (questionItem) {
                        questionItem.classList.remove('active');
                        questionItem.classList.add('error');
                    }
                    
                    qaResults.push({
                        question,
                        answer: errorMsg,
                        responseTime,
                        error: true
                    });
                    
                    // Write error to QuickBase
                    await writeToQuickBase(question, errorMsg, {
                        responseTime: responseTime,
                        source: 'tester',
                        testRunId: `test_${Date.now()}`,
                        adminNotes: `API Error: ${response.status}`
                    });
                }
            } catch (error) {
                addDiagnosticLog(`Exception Q${index + 1}: ${error.message}`, 'error', error);
                const errorMsg = `Error: ${error.message}`;
                updateAnswerInTranscript(index, errorMsg, Date.now() - startTime, true);
                
                if (questionItem) {
                    questionItem.classList.remove('active');
                    questionItem.classList.add('error');
                }
                
                qaResults.push({
                    question,
                    answer: errorMsg,
                    responseTime: Date.now() - startTime,
                    error: true
                });
                
                // Write exception to QuickBase
                await writeToQuickBase(question, errorMsg, {
                    responseTime: Date.now() - startTime,
                    source: 'tester',
                    testRunId: `test_${Date.now()}`,
                    adminNotes: `Exception: ${error.message}`
                });
            }
            
            updateStats();
        }

        // Extract answer from API response
        function extractAnswer(data) {
            if (!data || !Array.isArray(data)) {
                return 'No response';
            }

            let texts = [];
            
            for (const item of data) {
                if (item.type === 'text' && item.payload?.message) {
                    texts.push(item.payload.message);
                } else if (item.type === 'speak' && item.payload?.message) {
                    texts.push(item.payload.message);
                }
            }

            return texts.length > 0 ? texts.join('\n\n') : 'No response';
        }

        // Add question to transcript
        function addQuestionToTranscript(question, index) {
            const transcript = document.getElementById('transcript');
            
            const qaDiv = document.createElement('div');
            qaDiv.className = 'qa-pair';
            qaDiv.id = `qa-${index}`;
            
            const questionDiv = document.createElement('div');
            questionDiv.className = 'qa-question';
            questionDiv.innerHTML = `<span class="number">Q${index + 1}</span><span>${question}</span>`;
            
            const answerDiv = document.createElement('div');
            answerDiv.className = 'qa-waiting';
            answerDiv.textContent = '⏳ Waiting for response...';
            answerDiv.id = `answer-${index}`;
            
            qaDiv.appendChild(questionDiv);
            qaDiv.appendChild(answerDiv);
            transcript.appendChild(qaDiv);
            
            transcript.scrollTop = transcript.scrollHeight;
        }

        // Update answer in transcript
        function updateAnswerInTranscript(index, answer, responseTime, isError = false) {
            const answerDiv = document.getElementById(`answer-${index}`);
            
            if (answerDiv) {
                answerDiv.className = `qa-answer ${isError ? 'error' : ''}`;
                answerDiv.textContent = answer;
                
                // Add metadata
                const metaDiv = document.createElement('div');
                metaDiv.className = 'qa-metadata';
                metaDiv.innerHTML = `
                    <span>⏱️ ${(responseTime / 1000).toFixed(2)}s</span>
                    <span>🕐 ${new Date().toLocaleTimeString()}</span>
                `;
                
                const qaDiv = document.getElementById(`qa-${index}`);
                if (qaDiv) {
                    qaDiv.appendChild(metaDiv);
                }
            }
            
            const transcript = document.getElementById('transcript');
            transcript.scrollTop = transcript.scrollHeight;
        }

        // Stop test
        function stopTest() {
            isTesting = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            
            if (currentQuestionIndex < questions.length) {
                setStatus('⏹️ Test stopped', 'warning');
                addSystemMessage('Test stopped by user');
                addDiagnosticLog('Test stopped by user', 'warning');
            }
        }

        // Clear transcript
        function clearTranscript() {
            if (!confirm('Clear all results?')) return;
            
            qaResults = [];
            currentQuestionIndex = 0;
            document.getElementById('transcript').innerHTML = '';
            
            // Reset question items
            questions.forEach((q, index) => {
                const item = document.getElementById(`question-${index}`);
                if (item) {
                    item.className = 'question-item';
                }
            });
            
            updateStats();
            setStatus('🗑️ Transcript cleared', 'info');
            addSystemMessage('Transcript cleared');
        }

        // Copy to clipboard
        function copyToClipboard() {
            if (qaResults.length === 0) {
                setStatus('❌ No results to copy', 'error');
                return;
            }
            
            let text = '=== VOICEFLOW TEST RESULTS ===\n';
            text += `Generated: ${new Date().toLocaleString()}\n`;
            text += `Total Questions: ${qaResults.length}\n`;
            text += `Endpoint Used: ${workingEndpoint ? API_ENDPOINTS[workingEndpoint.key].name : 'Unknown'}\n\n`;
            text += '═══════════════════════════════\n\n';
            
            qaResults.forEach((qa, index) => {
                text += `Q${index + 1}: ${qa.question}\n`;
                text += `A${index + 1}: ${qa.answer}\n`;
                text += `Time: ${(qa.responseTime / 1000).toFixed(2)}s\n`;
                text += '\n───────────────────────────────\n\n';
            });
            
            navigator.clipboard.writeText(text).then(() => {
                setStatus('✅ Copied to clipboard!', 'success');
                addSystemMessage('Results copied to clipboard');
            });
        }

        // Copy diagnostic log
        function copyDiagnosticLog() {
            if (diagnosticHistory.length === 0) {
                setStatus('❌ No diagnostic log to copy', 'error');
                return;
            }
            
            let text = '=== DIAGNOSTIC LOG ===\n';
            text += `Generated: ${new Date().toLocaleString()}\n\n`;
            
            diagnosticHistory.forEach(entry => {
                text += `[${entry.timestamp}] [${entry.type.toUpperCase()}] ${entry.message}\n`;
                if (entry.data) {
                    text += JSON.stringify(entry.data, null, 2) + '\n';
                }
                text += '\n';
            });
            
            navigator.clipboard.writeText(text).then(() => {
                setStatus('✅ Diagnostic log copied!', 'success');
                addSystemMessage('Diagnostic log copied to clipboard');
            });
        }

        // Export to CSV
        function exportToCSV() {
            if (qaResults.length === 0) {
                setStatus('❌ No results to export', 'error');
                return;
            }
            
            let csv = 'Question Number,Question,Answer,Response Time (seconds),Timestamp,Endpoint\n';
            
            qaResults.forEach((qa, index) => {
                const question = qa.question.replace(/"/g, '""');
                const answer = qa.answer.replace(/"/g, '""');
                const time = (qa.responseTime / 1000).toFixed(2);
                const timestamp = new Date().toISOString();
                const endpoint = workingEndpoint ? API_ENDPOINTS[workingEndpoint.key].name : 'Unknown';
                csv += `${index + 1},"${question}","${answer}",${time},"${timestamp}","${endpoint}"\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `voiceflow-test-diagnostic-${new Date().toISOString().slice(0,10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            setStatus('✅ CSV exported!', 'success');
            addSystemMessage('Results exported to CSV');
        }

        // Utility: sleep
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            addDiagnosticLog('=== TESTER v7.0 - QUICKBASE INTEGRATION ===', 'success');
            setStatus('💡 Enter API key and run diagnostic to begin', 'info');
            addSystemMessage('Tester v7.0 - QuickBase Integration Ready');
            addDiagnosticLog('Ready to test and log to QuickBase', 'info');
            
            // Check QB config
            const qbEnabled = document.getElementById('qbEnabled').checked;
            const qbRealm = document.getElementById('qbRealm').value.trim();
            const qbToken = document.getElementById('qbToken').value.trim();
            const qbTableId = document.getElementById('qbTableId').value.trim();
            
            if (qbEnabled && qbRealm && qbToken && qbTableId) {
                addDiagnosticLog('QuickBase configuration detected', 'success');
                updateQBStatus('📊 QuickBase ready - will log after each Q&A', 'success');
            } else if (qbEnabled) {
                addDiagnosticLog('QuickBase enabled but incomplete config', 'warning');
                updateQBStatus('⚠️ QuickBase config incomplete', 'warning');
            }
        });

        // API key input listener
        document.getElementById('apiKey').addEventListener('input', () => {
            // Auto-extract project ID if possible
            const apiKey = document.getElementById('apiKey').value.trim();
            if (apiKey && !document.getElementById('projectId').value) {
                const extractedId = extractProjectId(apiKey);
                if (extractedId) {
                    document.getElementById('projectId').value = extractedId;
                    addDiagnosticLog(`Auto-detected Project ID: ${extractedId}`, 'info');
                }
            }
            checkReadyToTest();
        });
    </script>
</body>
</html>
